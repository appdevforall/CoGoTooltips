<html>
 <head>
  <meta charset="utf-8"/>
  <link href="doc_style.css" rel="stylesheet"/>
 </head>
 <body>
  <a class="menu-link" href="toc.html">
   MENU
  </a>
  <hr/>
  <div class="article-content">
   <h1 data-toc="mapping-strings-from-c" id="mapping-strings-from-c.md">
    Mapping Strings from C – tutorial
   </h1>
   <aside class="prompt" data-title="" data-type="warning" id="i6jpzr_2">
    <p id="i6jpzr_14">
     The C libraries import is
     <a data-tooltip="Here's a quick guide to these stability levels and their meaning:" href="components-stability.html#stability-levels-explained" id="i6jpzr_16">
      Experimental
     </a>
     . All Kotlin declarations generated by the
     <code class="code" id="i6jpzr_17">
      cinterop
     </code>
     tool from C libraries should have the
     <code class="code" id="i6jpzr_18">
      @ExperimentalForeignApi
     </code>
     annotation.
    </p>
    <p id="i6jpzr_15">
     Native platform libraries shipped with Kotlin/Native (like Foundation, UIKit, and POSIX), require opt-in only for some APIs. In such cases, you get an IDE warning.
    </p>
   </aside>
   <p id="i6jpzr_3">
    This is the last tutorial in the series. The first tutorial of the series is
    <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="mapping-primitive-data-types-from-c.html" id="i6jpzr_19">
     Mapping primitive data types from C
    </a>
    . There are also
    <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="mapping-struct-union-types-from-c.html" id="i6jpzr_20">
     Mapping struct and union types from C
    </a>
    and
    <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="mapping-function-pointers-from-c.html" id="i6jpzr_21">
     Mapping function pointers from C
    </a>
    tutorials.
   </p>
   <p id="i6jpzr_4">
    In this tutorial, you'll see how to deal with C strings in Kotlin/Native. You will learn how to:
   </p>
   <ul class="list _bullet" id="i6jpzr_5">
    <li class="list__item" id="i6jpzr_22">
     <p>
      <a data-tooltip="Let's try to use the API from Kotlin. Call pass_string first:" href="#pass-kotlin-string-to-c" id="i6jpzr_25">
       Pass a Kotlin string to C
      </a>
     </p>
    </li>
    <li class="list__item" id="i6jpzr_23">
     <p>
      <a data-tooltip="This time you'll take a returned char * from the return_string function and turn it into a Kotlin string. For that, do the following in Kotlin:" href="#read-c-strings-in-kotlin" id="i6jpzr_26">
       Read a C string in Kotlin
      </a>
     </p>
    </li>
    <li class="list__item" id="i6jpzr_24">
     <p>
      <a data-tooltip="This time we will ask a C function to write us a C string to a given buffer. The function is called copy_string. It takes a pointer to the location writing characters and the allowed buffer size. The function returns something to indicate if it has succeeded or failed. Let's assume…" href="#receive-c-string-bytes-from-kotlin" id="i6jpzr_27">
       Receive C string bytes into a Kotlin string
      </a>
     </p>
    </li>
   </ul>
   <section class="chapter">
    <h2 data-toc="working-with-c-strings" id="working-with-c-strings">
     Working with C strings
    </h2>
    <p id="i6jpzr_28">
     There is no dedicated type in C language for strings. A developer knows from a method signature or the documentation, whether a given
     <code class="code" id="i6jpzr_35">
      char *
     </code>
     means a C string in the context. Strings in the C language are null-terminated, a trailing zero character
     <code class="code" id="i6jpzr_36">
      \0
     </code>
     is added at the end of a bytes sequence to mark a string termination. Usually,
     <a data-external="true" href="https://en.wikipedia.org/wiki/UTF-8" id="i6jpzr_37" rel="noopener noreferrer">
      UTF-8 encoded strings
     </a>
     are used. The UTF-8 encoding uses variable width characters, and it is backward compatible with
     <a data-external="true" href="https://en.wikipedia.org/wiki/ASCII" id="i6jpzr_38" rel="noopener noreferrer">
      ASCII
     </a>
     . Kotlin/Native uses UTF-8 character encoding by default.
    </p>
    <p id="i6jpzr_29">
     The best way to understand the mapping between C and Kotlin languages is to try it out on a small example. Create a small library headers for that. First, create a
     <code class="code" id="i6jpzr_39">
      lib.h
     </code>
     file with the following declaration of functions that deal with the C strings:
    </p>
    <div class="code-block" data-lang="c">
     #ifndef LIB2_H_INCLUDED
#define LIB2_H_INCLUDED

void pass_string(char* str);
char* return_string();
int copy_string(char* str, int size);

#endif
    </div>
    <p id="i6jpzr_31">
     In the example, you see the most popular ways to pass or receive a string in the C language. Take the return of
     <code class="code" id="i6jpzr_40">
      return_string
     </code>
     with care. In general, it is best to make sure you use the right function to dispose the returned
     <code class="code" id="i6jpzr_41">
      char*
     </code>
     with the right
     <code class="code" id="i6jpzr_42">
      free(..)
     </code>
     function call.
    </p>
    <p id="i6jpzr_32">
     Kotlin/Native comes with the
     <code class="code" id="i6jpzr_43">
      cinterop
     </code>
     tool; the tool generates bindings between the C language and Kotlin. It uses a
     <code class="code" id="i6jpzr_44">
      .def
     </code>
     file to specify a C library to import. More details on this are in the
     <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="native-c-interop.html" id="i6jpzr_45">
      Interop with C Libraries
     </a>
     tutorial. The quickest way to try out C API mapping is to have all C declarations in the
     <code class="code" id="i6jpzr_46">
      interop.def
     </code>
     file, without creating any
     <code class="code" id="i6jpzr_47">
      .h
     </code>
     of
     <code class="code" id="i6jpzr_48">
      .c
     </code>
     files at all. Then place the C declarations in a
     <code class="code" id="i6jpzr_49">
      interop.def
     </code>
     file after the special
     <code class="code" id="i6jpzr_50">
      ---
     </code>
     separator line:
    </p>
    <div class="code-block" data-lang="c">
     headers = lib.h
---

void pass_string(char* str) {
}

char* return_string() {
  return "C string";
}

int copy_string(char* str, int size) {
    *str++ = 'C';
    *str++ = ' ';
    *str++ = 'K';
    *str++ = '/';
    *str++ = 'N';
    *str++ = 0;
    return 0;
}
    </div>
    <p id="i6jpzr_34">
     The
     <code class="code" id="i6jpzr_51">
      interop.def
     </code>
     file is enough to compile and run the application or open it in an IDE. Now it is time to create project files, open the project in
     <a data-external="true" href="https://jetbrains.com/idea" id="i6jpzr_52" rel="noopener noreferrer">
      IntelliJ IDEA
     </a>
     and run it.
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="inspect-generated-kotlin-apis-for-a-c-library" id="inspect-generated-kotlin-apis-for-a-c-library">
     Inspect generated Kotlin APIs for a C library
    </h2>
    <p id="i6jpzr_53">
     While it is possible to use the command line, either directly or by combining it with a script file (such as
     <code class="code" id="i6jpzr_62">
      .sh
     </code>
     or
     <code class="code" id="i6jpzr_63">
      .bat
     </code>
     file), this approach doesn't scale well for big projects that have hundreds of files and libraries. It is then better to use the Kotlin/Native compiler with a build system, as it helps to download and cache the Kotlin/Native compiler binaries and libraries with transitive dependencies and run the compiler and tests. Kotlin/Native can use the
     <a data-external="true" href="https://gradle.org" id="i6jpzr_64" rel="noopener noreferrer">
      Gradle
     </a>
     build system through the
     <a data-tooltip="Projects targeting multiple platforms, called multiplatform projects, require the kotlin-multiplatform plugin." href="gradle-configure-project.html#targeting-multiple-platforms" id="i6jpzr_65">
      kotlin-multiplatform
     </a>
     plugin.
    </p>
    <p id="i6jpzr_54">
     We covered the basics of setting up an IDE compatible project with Gradle in the
     <a data-tooltip="In this section, you'll learn how to manually create a Kotlin/Native application using Gradle. It's the default build system for Kotlin/Native and Kotlin Multiplatform projects, which is also commonly used in Java, Android, and other ecosystems." href="native-get-started.html#using-gradle" id="i6jpzr_66">
      Get started with Kotlin/Native
     </a>
     tutorial. Please check it out if you are looking for detailed first steps and instructions on how to start a new Kotlin/Native project and open it in IntelliJ IDEA. In this tutorial, we'll look at the advanced C interop related usages of Kotlin/Native and
     <a data-tooltip="Projects targeting multiple platforms, called multiplatform projects, require the kotlin-multiplatform plugin." href="gradle-configure-project.html#targeting-multiple-platforms" id="i6jpzr_67">
      multiplatform
     </a>
     builds with Gradle.
    </p>
    <p id="i6jpzr_55">
     First, create a project folder. All the paths in this tutorial will be relative to this folder. Sometimes the missing directories will have to be created before any new files can be added.
    </p>
    <p id="i6jpzr_56">
     Use the following
     <code class="code" id="i6jpzr_68">
      build.gradle(.kts)
     </code>
     Gradle build file:
    </p>
    <div class="tabs" data-anchors="[i6jpzr_69,i6jpzr_70]" data-group="build-script" id="i6jpzr_57">
     <div class="tabs__content" data-gtm="tab" data-sync-tabs="kotlin" data-title="Kotlin" id="i6jpzr_69">
      <div class="code-block" data-lang="kotlin" data-title="Kotlin">
       plugins {
    kotlin("multiplatform") version "2.1.0"
}

repositories {
    mavenCentral()
}

kotlin {
    linuxX64("native") { // on Linux
        // macosX64("native") { // on x86_64 macOS
        // macosArm64("native") { // on Apple Silicon macOS
        // mingwX64("native") { // on Windows
        val main by compilations.getting
        val interop by main.cinterops.creating

        binaries {
            executable()
        }
    }
}

tasks.wrapper {
    gradleVersion = "8.10"
    distributionType = Wrapper.DistributionType.BIN
}
      </div>
     </div>
     <div class="tabs__content" data-gtm="tab" data-sync-tabs="groovy" data-title="Groovy" id="i6jpzr_70">
      <div class="code-block" data-lang="groovy" data-title="Groovy">
       plugins {
    id 'org.jetbrains.kotlin.multiplatform' version '2.1.0'
}

repositories {
    mavenCentral()
}

kotlin {
    linuxX64('native') { // on Linux
        // macosX64("native") { // on x86_64 macOS
        // macosArm64("native") { // on Apple Silicon macOS
        // mingwX64('native') { // on Windows
        compilations.main.cinterops {
            interop
        }

        binaries {
            executable()
        }
    }
}

wrapper {
    gradleVersion = '8.10'
    distributionType = 'BIN'
}
      </div>
     </div>
    </div>
    <p id="i6jpzr_58">
     The project file configures the C interop as an additional step of the build. Let's move the
     <code class="code" id="i6jpzr_73">
      interop.def
     </code>
     file to the
     <code class="code" id="i6jpzr_74">
      src/nativeInterop/cinterop
     </code>
     directory. Gradle recommends using conventions instead of configurations, for example, the source files are expected to be in the
     <code class="code" id="i6jpzr_75">
      src/nativeMain/kotlin
     </code>
     folder. By default, all the symbols from C are imported to the
     <code class="code" id="i6jpzr_76">
      interop
     </code>
     package, you may want to import the whole package in our
     <code class="code" id="i6jpzr_77">
      .kt
     </code>
     files. Check out the
     <a data-tooltip="The Kotlin Multiplatform Gradle plugin is a tool for creating Kotlin Multiplatform projects. Here we provide a reference of its contents; use it as a reminder when writing Gradle build scripts for Kotlin Multiplatform projects. Learn the concepts of Kotlin Multiplatform projects,…" href="multiplatform-dsl-reference.html" id="i6jpzr_78">
      Multiplatform Gradle DSL reference
     </a>
     to learn about all the different ways you could configure it.
    </p>
    <p id="i6jpzr_59">
     Let's create a
     <code class="code" id="i6jpzr_79">
      src/nativeMain/kotlin/hello.kt
     </code>
     stub file with the following content to see how C string declarations are visible from Kotlin:
    </p>
    <div class="code-block" data-lang="kotlin">
     import interop.*

fun main() {
    println("Hello Kotlin/Native!")

    pass_string(/*fix me*/)
    val useMe = return_string()
    val useMe2 = copy_string(/*fix me*/)
}
    </div>
    <p id="i6jpzr_61">
     Now you are ready to
     <a data-tooltip="In this tutorial, you'll learn how to create a Kotlin/Native application. Choose the tool that works best for you and create your app using:" href="native-get-started.html" id="i6jpzr_80">
      open the project in IntelliJ IDEA
     </a>
     and to see how to fix the example project. While doing that, see how C strings are mapped into Kotlin/Native.
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="strings-in-kotlin" id="strings-in-kotlin">
     Strings in Kotlin
    </h2>
    <p id="i6jpzr_81">
     With the help of IntelliJ IDEA's
     <span class="control" id="i6jpzr_85">
      Go to | Declaration
     </span>
     or compiler errors, you see the following generated API for the C functions:
    </p>
    <div class="code-block" data-lang="kotlin">
     fun pass_string(str: CValuesRef&lt;ByteVar /* = ByteVarOf&lt;Byte&gt; */&gt;?)
fun return_string(): CPointer&lt;ByteVar /* = ByteVarOf&lt;Byte&gt; */&gt;?
fun copy_string(str: CValuesRef&lt;ByteVar /* = ByteVarOf&lt;Byte&gt; */&gt;?, size: Int): Int
    </div>
    <p id="i6jpzr_83">
     These declarations look clear. All
     <code class="code" id="i6jpzr_86">
      char *
     </code>
     pointers are turned into
     <code class="code" id="i6jpzr_87">
      str: CValuesRef&lt;ByteVar&gt;?
     </code>
     for parameters and to
     <code class="code" id="i6jpzr_88">
      CPointer&lt;ByteVar&gt;?
     </code>
     in return types. Kotlin turns
     <code class="code" id="i6jpzr_89">
      char
     </code>
     type into
     <code class="code" id="i6jpzr_90">
      kotlin.Byte
     </code>
     type, as it is usually an 8-bit signed value.
    </p>
    <p id="i6jpzr_84">
     In the generated Kotlin declarations, you see that
     <code class="code" id="i6jpzr_91">
      str
     </code>
     is represented as
     <code class="code" id="i6jpzr_92">
      CValuesRef&lt;ByteVar/&gt;?
     </code>
     . The type is nullable, and you can simply pass Kotlin
     <code class="code" id="i6jpzr_93">
      null
     </code>
     as the parameter value.
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="pass-kotlin-string-to-c" id="pass-kotlin-string-to-c">
     Pass Kotlin string to C
    </h2>
    <p id="i6jpzr_94">
     Let's try to use the API from Kotlin. Call
     <code class="code" id="i6jpzr_97">
      pass_string
     </code>
     first:
    </p>
    <div class="code-block" data-lang="kotlin">
     fun passStringToC() {
    val str = "this is a Kotlin String"
    pass_string(str.cstr)
}
    </div>
    <p id="i6jpzr_96">
     Passing a Kotlin string to C is easy, thanks to the fact that there is
     <code class="code" id="i6jpzr_98">
      String.cstr
     </code>
     <a data-tooltip="Kotlin supports extension properties much like it supports functions:" href="extensions.html#extension-properties" id="i6jpzr_99">
      extension property
     </a>
     in Kotlin for it. There is also
     <code class="code" id="i6jpzr_100">
      String.wcstr
     </code>
     for cases when you need UTF-16 wide characters.
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="read-c-strings-in-kotlin" id="read-c-strings-in-kotlin">
     Read C Strings in Kotlin
    </h2>
    <p id="i6jpzr_101">
     This time you'll take a returned
     <code class="code" id="i6jpzr_106">
      char *
     </code>
     from the
     <code class="code" id="i6jpzr_107">
      return_string
     </code>
     function and turn it into a Kotlin string. For that, do the following in Kotlin:
    </p>
    <div class="code-block" data-lang="kotlin">
     fun passStringToC() {
    val stringFromC = return_string()?.toKString()

    println("Returned from C: $stringFromC")
}
    </div>
    <p id="i6jpzr_103">
     This code uses the
     <code class="code" id="i6jpzr_108">
      toKString()
     </code>
     extension function above. Please do not miss out the
     <code class="code" id="i6jpzr_109">
      toString()
     </code>
     function. The
     <code class="code" id="i6jpzr_110">
      toKString()
     </code>
     has two overloaded extension functions in Kotlin:
    </p>
    <div class="code-block" data-lang="kotlin">
     fun CPointer&lt;ByteVar&gt;.toKString(): String
fun CPointer&lt;ShortVar&gt;.toKString(): String
    </div>
    <p id="i6jpzr_105">
     The first extension takes a
     <code class="code" id="i6jpzr_111">
      char *
     </code>
     as a UTF-8 string and turns it into a String. The second function does the same but for wide UTF-16 strings.
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="receive-c-string-bytes-from-kotlin" id="receive-c-string-bytes-from-kotlin">
     Receive C string bytes from Kotlin
    </h2>
    <p id="i6jpzr_112">
     This time we will ask a C function to write us a C string to a given buffer. The function is called
     <code class="code" id="i6jpzr_115">
      copy_string
     </code>
     . It takes a pointer to the location writing characters and the allowed buffer size. The function returns something to indicate if it has succeeded or failed. Let's assume
     <code class="code" id="i6jpzr_116">
      0
     </code>
     means it succeeded, and the supplied buffer was big enough:
    </p>
    <div class="code-block" data-lang="kotlin">
     fun sendString() {
    val buf = ByteArray(255)
    buf.usePinned { pinned -&gt;
        if (copy_string(pinned.addressOf(0), buf.size - 1) != 0) {
            throw Error("Failed to read string from C")
        }
    }

    val copiedStringFromC = buf.decodeToString()
    println("Message from C: $copiedStringFromC")
}
    </div>
    <p id="i6jpzr_114">
     First of all, you need to have a native pointer to pass to the C function. Use the
     <code class="code" id="i6jpzr_117">
      usePinned
     </code>
     extension function to temporarily pin the native memory address of the byte array. The C function fills in the byte array with data. Use another extension function
     <code class="code" id="i6jpzr_118">
      ByteArray.decodeToString()
     </code>
     to turn the byte array into a Kotlin
     <code class="code" id="i6jpzr_119">
      String
     </code>
     , assuming UTF-8 encoding.
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="fix-the-code" id="fix-the-code">
     Fix the Code
    </h2>
    <p id="i6jpzr_120">
     You've now seen all the definitions and it is time to fix the code. Run the
     <code class="code" id="i6jpzr_124">
      runDebugExecutableNative
     </code>
     Gradle task
     <a data-tooltip="In this tutorial, you'll learn how to create a Kotlin/Native application. Choose the tool that works best for you and create your app using:" href="native-get-started.html" id="i6jpzr_125">
      in the IDE
     </a>
     or use the following command to run the code:
    </p>
    <div class="code-block" data-lang="bash">
     ./gradlew runDebugExecutableNative
    </div>
    <p id="i6jpzr_122">
     The code in the final
     <code class="code" id="i6jpzr_126">
      hello.kt
     </code>
     file may look like this:
    </p>
    <div class="code-block" data-lang="kotlin">
     import interop.*
import kotlinx.cinterop.*

fun main() {
    println("Hello Kotlin/Native!")

    val str = "this is a Kotlin String"
    pass_string(str.cstr)

    val useMe = return_string()?.toKString() ?: error("null pointer returned")
    println(useMe)

    val copyFromC = ByteArray(255).usePinned { pinned -&gt;
        val useMe2 = copy_string(pinned.addressOf(0), pinned.get().size - 1)
        if (useMe2 != 0) throw Error("Failed to read string from C")
        pinned.get().decodeToString()
    }

    println(copyFromC)
}
    </div>
   </section>
   <section class="chapter">
    <h2 data-toc="next-steps" id="next-steps">
     Next steps
    </h2>
    <p id="i6jpzr_127">
     Continue to explore more C language types and their representation in Kotlin/Native in our other tutorials:
    </p>
    <ul class="list _bullet" id="i6jpzr_128">
     <li class="list__item" id="i6jpzr_130">
      <p>
       <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="mapping-primitive-data-types-from-c.html" id="i6jpzr_133">
        Mapping primitive data types from C
       </a>
      </p>
     </li>
     <li class="list__item" id="i6jpzr_131">
      <p>
       <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="mapping-struct-union-types-from-c.html" id="i6jpzr_134">
        Mapping struct and union types from C
       </a>
      </p>
     </li>
     <li class="list__item" id="i6jpzr_132">
      <p>
       <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="mapping-function-pointers-from-c.html" id="i6jpzr_135">
        Mapping function pointers from C
       </a>
      </p>
     </li>
    </ul>
    <p id="i6jpzr_129">
     The
     <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="native-c-interop.html" id="i6jpzr_136">
      C Interop documentation
     </a>
     documentation covers more advanced scenarios of the interop.
    </p>
   </section>
   <div class="last-modified">
    Last modified: 16 December 2024
   </div>
   <div data-feedback-placeholder="true">
   </div>
  </div>
 </body>
</html>
