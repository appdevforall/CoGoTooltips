<html>
 <head>
  <meta charset="utf-8"/>
  <link href="doc_style.css" rel="stylesheet"/>
 </head>
 <body>
  <a class="menu-link" href="toc.html">
   MENU
  </a>
  <hr/>
  <div class="article-content">
   <h1 data-toc="native-dynamic-libraries" id="native-dynamic-libraries.md">
    Kotlin/Native as a dynamic library â€“ tutorial
   </h1>
   <p id="-gt78t0_2">
    You can create dynamic libraries to use Kotlin code from existing programs. This enables code sharing across many platforms or languages, including JVM, Python, Android, and others.
   </p>
   <aside class="prompt" data-title="" data-type="tip" id="-gt78t0_3">
    <p id="-gt78t0_15">
     For iOS and other Apple targets, we recommend generating a framework. See the
     <a data-tooltip="The Objective-C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from Objective-C libraries should have the @ExperimentalForeignApi annotation." href="apple-framework.html" id="-gt78t0_16">
      Kotlin/Native as an Apple framework
     </a>
     tutorial.
    </p>
   </aside>
   <p id="-gt78t0_4">
    You can use the Kotlin/Native code from existing native applications or libraries. For this, you need to compile the Kotlin code into a dynamic library in the
    <code class="code" id="-gt78t0_17">
     .so
    </code>
    ,
    <code class="code" id="-gt78t0_18">
     .dylib
    </code>
    , or
    <code class="code" id="-gt78t0_19">
     .dll
    </code>
    format.
   </p>
   <p id="-gt78t0_5">
    In this tutorial, you will:
   </p>
   <ul class="list _bullet" id="-gt78t0_6">
    <li class="list__item" id="-gt78t0_20">
     <p>
      <a data-tooltip="The Kotlin/Native compiler can produce a dynamic library from the Kotlin code. A dynamic library often comes with a .h header file, which you use to call the compiled code from C." href="#create-a-kotlin-library" id="-gt78t0_24">
       Compile Kotlin code to a dynamic library
      </a>
     </p>
    </li>
    <li class="list__item" id="-gt78t0_21">
     <p>
      <a data-tooltip="Let's examine how Kotlin/Native declarations are mapped to C functions." href="#generated-header-file" id="-gt78t0_25">
       Examine generated C headers
      </a>
     </p>
    </li>
    <li class="list__item" id="-gt78t0_22">
     <p>
      <a data-tooltip="Using the generated headers from C is straightforward. In the library directory, create the main.c file with the following code:" href="#use-generated-headers-from-c" id="-gt78t0_26">
       Use the Kotlin dynamic library from C
      </a>
     </p>
    </li>
    <li class="list__item" id="-gt78t0_23">
     <p>
      <a data-tooltip="To compile the C code and link it with the dynamic library, navigate to the library directory and run the following command:" href="#compile-and-run-the-project" id="-gt78t0_27">
       Compile and run the project
      </a>
     </p>
    </li>
   </ul>
   <p id="-gt78t0_7">
    You can use the command line to generate a Kotlin library, either directly or with a script file (such as
    <code class="code" id="-gt78t0_28">
     .sh
    </code>
    or
    <code class="code" id="-gt78t0_29">
     .bat
    </code>
    file). However, this approach doesn't scale well for big projects that have hundreds of files and libraries. Using a build system simplifies the process by downloading and caching the Kotlin/Native compiler binaries and libraries with transitive dependencies, and by running the compiler and tests. Kotlin/Native can use the
    <a data-external="true" href="https://gradle.org" id="-gt78t0_30" rel="noopener noreferrer">
     Gradle
    </a>
    build system through the
    <a data-tooltip="Projects targeting multiple platforms, called multiplatform projects, require the kotlin-multiplatform plugin." href="gradle-configure-project.html#targeting-multiple-platforms" id="-gt78t0_31">
     Kotlin Multiplatform plugin
    </a>
    .
   </p>
   <p id="-gt78t0_8">
    Let's examine the advanced C interop-related usages of Kotlin/Native and
    <a data-tooltip="Projects targeting multiple platforms, called multiplatform projects, require the kotlin-multiplatform plugin." href="gradle-configure-project.html#targeting-multiple-platforms" id="-gt78t0_32">
     Kotlin Multiplatform
    </a>
    builds with Gradle.
   </p>
   <aside class="prompt" data-title="" data-type="note" id="-gt78t0_9">
    <p id="-gt78t0_33">
     If you use a Mac and want to create and run applications for macOS or other Apple targets, you also need to install the
     <a data-external="true" href="https://developer.apple.com/download/" id="-gt78t0_34" rel="noopener noreferrer">
      Xcode Command Line Tools
     </a>
     , launch it, and accept the license terms first.
    </p>
   </aside>
   <section class="chapter">
    <h2 data-toc="create-a-kotlin-library" id="create-a-kotlin-library">
     Create a Kotlin library
    </h2>
    <p id="-gt78t0_35">
     The Kotlin/Native compiler can produce a dynamic library from the Kotlin code. A dynamic library often comes with a
     <code class="code" id="-gt78t0_43">
      .h
     </code>
     header file, which you use to call the compiled code from C.
    </p>
    <p id="-gt78t0_36">
     Let's create a Kotlin library and use it from a C program.
    </p>
    <aside class="prompt" data-title="" data-type="tip" id="-gt78t0_37">
     <p id="-gt78t0_44">
      See the
      <a data-tooltip="In this section, you'll learn how to manually create a Kotlin/Native application using Gradle. It's the default build system for Kotlin/Native and Kotlin Multiplatform projects, which is also commonly used in Java, Android, and other ecosystems." href="native-get-started.html#using-gradle" id="-gt78t0_45">
       Get started with Kotlin/Native
      </a>
      tutorial for detailed first steps and instructions on how to create a new Kotlin/Native project and open it in IntelliJ IDEA.
     </p>
    </aside>
    <ol class="list _decimal" id="-gt78t0_38" type="1">
     <li class="list__item" id="-gt78t0_46">
      <p id="-gt78t0_49">
       Navigate to the
       <code class="code" id="-gt78t0_51">
        src/nativeMain/kotlin
       </code>
       directory and create the
       <code class="code" id="-gt78t0_52">
        lib.kt
       </code>
       file with the following library contents:
      </p>
      <div class="code-block" data-lang="kotlin">
       package example

object Object { 
    val field = "A"
}

class Clazz {
    fun memberFunction(p: Int): ULong = 42UL
}

fun forIntegers(b: Byte, s: Short, i: UInt, l: Long) { }
fun forFloats(f: Float, d: Double) { }

fun strings(str: String) : String? {
    return "That is '$str' from C"
}

val globalString = "A global String"
      </div>
     </li>
     <li class="list__item" id="-gt78t0_47">
      <p id="-gt78t0_53">
       Update your
       <code class="code" id="-gt78t0_56">
        build.gradle(.kts)
       </code>
       Gradle build file with the following:
      </p>
      <div class="tabs" data-anchors="[-gt78t0_57,-gt78t0_58]" data-group="build-script" id="-gt78t0_54">
       <div class="tabs__content" data-gtm="tab" data-sync-tabs="kotlin" data-title="Kotlin" id="-gt78t0_57">
        <div class="code-block" data-lang="kotlin" data-title="Kotlin">
         plugins {
    kotlin("multiplatform") version "2.1.0"
}

repositories {
    mavenCentral()
}

kotlin {
    macosArm64("native") {    // macOS on Apple Silicon
    // macosX64("native") {   // macOS on x86_64 platforms
    // linuxArm64("native") { // Linux on ARM64 platforms
    // linuxX64("native") {   // Linux on x86_64 platforms
    // mingwX64("native") {   // Windows
        binaries {
            sharedLib {
                baseName = "native"       // macOS and Linux 
                // baseName = "libnative" // Windows
            }
        }
    }
}

tasks.wrapper {
    gradleVersion = "8.10"
    distributionType = Wrapper.DistributionType.ALL
}
        </div>
       </div>
       <div class="tabs__content" data-gtm="tab" data-sync-tabs="groovy" data-title="Groovy" id="-gt78t0_58">
        <div class="code-block" data-lang="groovy" data-title="Groovy">
         plugins {
    id 'org.jetbrains.kotlin.multiplatform' version '2.1.0'
}

repositories {
    mavenCentral()
}

kotlin {
    macosArm64("native") {    // Apple Silicon macOS
    // macosX64("native") {   // macOS on x86_64 platforms
    // linuxArm64("native") { // Linux on ARM64 platforms
    // linuxX64("native") {   // Linux on x86_64 platforms
    // mingwX64("native") {   // Windows
        binaries {
            sharedLib {
                baseName = "native"       // macOS and Linux 
                // baseName = "libnative" // Windows
            }
        }
    }
}

wrapper {
    gradleVersion = "8.10"
    distributionType = "ALL"
}
        </div>
       </div>
      </div>
      <ul class="list _bullet" id="-gt78t0_55">
       <li class="list__item" id="-gt78t0_61">
        <p>
         The
         <code class="code" id="-gt78t0_63">
          binaries {}
         </code>
         block configures the project to generate a dynamic or shared library.
        </p>
       </li>
       <li class="list__item" id="-gt78t0_62">
        <p>
         <code class="code" id="-gt78t0_64">
          libnative
         </code>
         is used as the library name, the prefix for the generated header file name. It also prefixes all declarations in the header file.
        </p>
       </li>
      </ul>
     </li>
     <li class="list__item" id="-gt78t0_48">
      <p id="-gt78t0_65">
       Run the
       <code class="code" id="-gt78t0_67">
        linkDebugSharedNative
       </code>
       Gradle task in the IDE or use the following console command in your terminal to build the library:
      </p>
      <div class="code-block" data-lang="bash">
       ./gradlew linkDebugSharedNative
      </div>
     </li>
    </ol>
    <p id="-gt78t0_39">
     The build generates the library into the
     <code class="code" id="-gt78t0_68">
      build/bin/native/debugShared
     </code>
     directory with the following files:
    </p>
    <ul class="list _bullet" id="-gt78t0_40">
     <li class="list__item" id="-gt78t0_69">
      <p>
       macOS
       <code class="code" id="-gt78t0_72">
        libnative_api.h
       </code>
       and
       <code class="code" id="-gt78t0_73">
        libnative.dylib
       </code>
      </p>
     </li>
     <li class="list__item" id="-gt78t0_70">
      <p>
       Linux:
       <code class="code" id="-gt78t0_74">
        libnative_api.h
       </code>
       and
       <code class="code" id="-gt78t0_75">
        libnative.so
       </code>
      </p>
     </li>
     <li class="list__item" id="-gt78t0_71">
      <p>
       Windows:
       <code class="code" id="-gt78t0_76">
        libnative_api.h
       </code>
       ,
       <code class="code" id="-gt78t0_77">
        libnative.def
       </code>
       , and
       <code class="code" id="-gt78t0_78">
        libnative.dll
       </code>
      </p>
     </li>
    </ul>
    <aside class="prompt" data-title="" data-type="tip" id="-gt78t0_41">
     <p id="-gt78t0_79">
      You can also use the
      <code class="code" id="-gt78t0_80">
       linkNative
      </code>
      Gradle task to generate both
      <code class="code" id="-gt78t0_81">
       debug
      </code>
      and
      <code class="code" id="-gt78t0_82">
       release
      </code>
      variants of the library.
     </p>
    </aside>
    <p id="-gt78t0_42">
     The Kotlin/Native compiler uses the same rules to generate the
     <code class="code" id="-gt78t0_83">
      .h
     </code>
     file for all platforms. Let's check out the C API of the Kotlin library.
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="generated-header-file" id="generated-header-file">
     Generated header file
    </h2>
    <p id="-gt78t0_84">
     Let's examine how Kotlin/Native declarations are mapped to C functions.
    </p>
    <p id="-gt78t0_85">
     In the
     <code class="code" id="-gt78t0_101">
      build/bin/native/debugShared
     </code>
     directory, open the
     <code class="code" id="-gt78t0_102">
      libnative_api.h
     </code>
     header file. The very first part contains the standard C/C++ header and footer:
    </p>
    <div class="code-block" data-lang="c">
     #ifndef KONAN_LIBNATIVE_H
#define KONAN_LIBNATIVE_H
#ifdef __cplusplus
extern "C" {
#endif

/// The rest of the generated code

#ifdef __cplusplus
}  /* extern "C" */
#endif
#endif  /* KONAN_LIBNATIVE_H */
    </div>
    <p id="-gt78t0_87">
     Following this, the
     <code class="code" id="-gt78t0_103">
      libnative_api.h
     </code>
     includes a block with the common type definitions:
    </p>
    <div class="code-block" data-lang="c">
     #ifdef __cplusplus
typedef bool            libnative_KBoolean;
#else
typedef _Bool           libnative_KBoolean;
#endif
typedef unsigned short     libnative_KChar;
typedef signed char        libnative_KByte;
typedef short              libnative_KShort;
typedef int                libnative_KInt;
typedef long long          libnative_KLong;
typedef unsigned char      libnative_KUByte;
typedef unsigned short     libnative_KUShort;
typedef unsigned int       libnative_KUInt;
typedef unsigned long long libnative_KULong;
typedef float              libnative_KFloat;
typedef double             libnative_KDouble;
typedef float __attribute__ ((__vector_size__ (16))) libnative_KVector128;
typedef void*              libnative_KNativePtr;
    </div>
    <p id="-gt78t0_89">
     Kotlin uses the
     <code class="code" id="-gt78t0_104">
      libnative_
     </code>
     prefix for all declarations in the created
     <code class="code" id="-gt78t0_105">
      libnative_api.h
     </code>
     file. Here's the complete list of type mappings:
    </p>
    <div class="table-wrapper">
     <table class="wide" id="-gt78t0_90">
      <thead>
       <tr class="ijRowHead" id="-gt78t0_106">
        <th id="-gt78t0_121">
         <p>
          Kotlin definition
         </p>
        </th>
        <th id="-gt78t0_122">
         <p>
          C type
         </p>
        </th>
       </tr>
      </thead>
      <tbody>
       <tr id="-gt78t0_107">
        <td id="-gt78t0_123">
         <p>
          <code class="code" id="-gt78t0_125">
           libnative_KBoolean
          </code>
         </p>
        </td>
        <td id="-gt78t0_124">
         <p>
          <code class="code" id="-gt78t0_126">
           bool
          </code>
          or
          <code class="code" id="-gt78t0_127">
           _Bool
          </code>
         </p>
        </td>
       </tr>
       <tr id="-gt78t0_108">
        <td id="-gt78t0_128">
         <p>
          <code class="code" id="-gt78t0_130">
           libnative_KChar
          </code>
         </p>
        </td>
        <td id="-gt78t0_129">
         <p>
          <code class="code" id="-gt78t0_131">
           unsigned short
          </code>
         </p>
        </td>
       </tr>
       <tr id="-gt78t0_109">
        <td id="-gt78t0_132">
         <p>
          <code class="code" id="-gt78t0_134">
           libnative_KByte
          </code>
         </p>
        </td>
        <td id="-gt78t0_133">
         <p>
          <code class="code" id="-gt78t0_135">
           signed char
          </code>
         </p>
        </td>
       </tr>
       <tr id="-gt78t0_110">
        <td id="-gt78t0_136">
         <p>
          <code class="code" id="-gt78t0_138">
           libnative_KShort
          </code>
         </p>
        </td>
        <td id="-gt78t0_137">
         <p>
          <code class="code" id="-gt78t0_139">
           short
          </code>
         </p>
        </td>
       </tr>
       <tr id="-gt78t0_111">
        <td id="-gt78t0_140">
         <p>
          <code class="code" id="-gt78t0_142">
           libnative_KInt
          </code>
         </p>
        </td>
        <td id="-gt78t0_141">
         <p>
          <code class="code" id="-gt78t0_143">
           int
          </code>
         </p>
        </td>
       </tr>
       <tr id="-gt78t0_112">
        <td id="-gt78t0_144">
         <p>
          <code class="code" id="-gt78t0_146">
           libnative_KLong
          </code>
         </p>
        </td>
        <td id="-gt78t0_145">
         <p>
          <code class="code" id="-gt78t0_147">
           long long
          </code>
         </p>
        </td>
       </tr>
       <tr id="-gt78t0_113">
        <td id="-gt78t0_148">
         <p>
          <code class="code" id="-gt78t0_150">
           libnative_KUByte
          </code>
         </p>
        </td>
        <td id="-gt78t0_149">
         <p>
          <code class="code" id="-gt78t0_151">
           unsigned char
          </code>
         </p>
        </td>
       </tr>
       <tr id="-gt78t0_114">
        <td id="-gt78t0_152">
         <p>
          <code class="code" id="-gt78t0_154">
           libnative_KUShort
          </code>
         </p>
        </td>
        <td id="-gt78t0_153">
         <p>
          <code class="code" id="-gt78t0_155">
           unsigned short
          </code>
         </p>
        </td>
       </tr>
       <tr id="-gt78t0_115">
        <td id="-gt78t0_156">
         <p>
          <code class="code" id="-gt78t0_158">
           libnative_KUInt
          </code>
         </p>
        </td>
        <td id="-gt78t0_157">
         <p>
          <code class="code" id="-gt78t0_159">
           unsigned int
          </code>
         </p>
        </td>
       </tr>
       <tr id="-gt78t0_116">
        <td id="-gt78t0_160">
         <p>
          <code class="code" id="-gt78t0_162">
           libnative_KULong
          </code>
         </p>
        </td>
        <td id="-gt78t0_161">
         <p>
          <code class="code" id="-gt78t0_163">
           unsigned long long
          </code>
         </p>
        </td>
       </tr>
       <tr id="-gt78t0_117">
        <td id="-gt78t0_164">
         <p>
          <code class="code" id="-gt78t0_166">
           libnative_KFloat
          </code>
         </p>
        </td>
        <td id="-gt78t0_165">
         <p>
          <code class="code" id="-gt78t0_167">
           float
          </code>
         </p>
        </td>
       </tr>
       <tr id="-gt78t0_118">
        <td id="-gt78t0_168">
         <p>
          <code class="code" id="-gt78t0_170">
           libnative_KDouble
          </code>
         </p>
        </td>
        <td id="-gt78t0_169">
         <p>
          <code class="code" id="-gt78t0_171">
           double
          </code>
         </p>
        </td>
       </tr>
       <tr id="-gt78t0_119">
        <td id="-gt78t0_172">
         <p>
          <code class="code" id="-gt78t0_174">
           libnative_KVector128
          </code>
         </p>
        </td>
        <td id="-gt78t0_173">
         <p>
          <code class="code" id="-gt78t0_175">
           float __attribute__ ((__vector_size__ (16))
          </code>
         </p>
        </td>
       </tr>
       <tr id="-gt78t0_120">
        <td id="-gt78t0_176">
         <p>
          <code class="code" id="-gt78t0_178">
           libnative_KNativePtr
          </code>
         </p>
        </td>
        <td id="-gt78t0_177">
         <p>
          <code class="code" id="-gt78t0_179">
           void*
          </code>
         </p>
        </td>
       </tr>
      </tbody>
     </table>
    </div>
    <p id="-gt78t0_91">
     The definition section of the
     <code class="code" id="-gt78t0_180">
      libnative_api.h
     </code>
     file shows how Kotlin primitive types are mapped to C primitive types. The Kotlin/Native compiler generates these entries automatically for every library. The reverse mapping is described in the
     <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="mapping-primitive-data-types-from-c.html" id="-gt78t0_181">
      Mapping primitive data types from C
     </a>
     tutorial.
    </p>
    <p id="-gt78t0_92">
     After the automatically generated type definitions, you'll find the separate type definitions used in your library:
    </p>
    <div class="code-block" data-lang="c">
     struct libnative_KType;
typedef struct libnative_KType libnative_KType;

/// Automatically generated type definitions

typedef struct {
  libnative_KNativePtr pinned;
} libnative_kref_example_Object;
typedef struct {
  libnative_KNativePtr pinned;
} libnative_kref_example_Clazz;
    </div>
    <p id="-gt78t0_94">
     In C, the
     <code class="code" id="-gt78t0_182">
      typedef struct { ... } TYPE_NAME
     </code>
     syntax declares the structure.
    </p>
    <aside class="prompt" data-title="" data-type="tip" id="-gt78t0_95">
     <p id="-gt78t0_183">
      See
      <a data-external="true" href="https://stackoverflow.com/questions/1675351/typedef-struct-vs-struct-definitions" id="-gt78t0_184" rel="noopener noreferrer">
       this StackOverflow thread
      </a>
      for more explanations of this pattern.
     </p>
    </aside>
    <p id="-gt78t0_96">
     As you can see from these definitions, Kotlin types are mapped using the same pattern:
     <code class="code" id="-gt78t0_185">
      Object
     </code>
     is mapped to
     <code class="code" id="-gt78t0_186">
      libnative_kref_example_Object
     </code>
     , and
     <code class="code" id="-gt78t0_187">
      Clazz
     </code>
     is mapped to
     <code class="code" id="-gt78t0_188">
      libnative_kref_example_Clazz
     </code>
     . All structs contain nothing but the
     <code class="code" id="-gt78t0_189">
      pinned
     </code>
     field with a pointer. The field type
     <code class="code" id="-gt78t0_190">
      libnative_KNativePtr
     </code>
     is defined as
     <code class="code" id="-gt78t0_191">
      void*
     </code>
     earlier in the file.
    </p>
    <p id="-gt78t0_97">
     Since C doesn't support namespaces, the Kotlin/Native compiler generates long names to avoid any possible clashes with other symbols in the existing native project.
    </p>
    <section class="chapter">
     <h3 data-toc="service-runtime-functions" id="service-runtime-functions">
      Service runtime functions
     </h3>
     <p id="-gt78t0_192">
      The
      <code class="code" id="-gt78t0_200">
       libnative_ExportedSymbols
      </code>
      structure defines all the functions provided by Kotlin/Native and your library. It uses nested anonymous structures heavily to mimic packages. The
      <code class="code" id="-gt78t0_201">
       libnative_
      </code>
      prefix comes from the library name.
     </p>
     <p id="-gt78t0_193">
      <code class="code" id="-gt78t0_202">
       libnative_ExportedSymbols
      </code>
      includes several helper functions in the header file:
     </p>
     <div class="code-block" data-lang="c">
      typedef struct {
  /* Service functions. */
  void (*DisposeStablePointer)(libnative_KNativePtr ptr);
  void (*DisposeString)(const char* string);
     </div>
     <p id="-gt78t0_195">
      These functions deal with Kotlin/Native objects.
      <code class="code" id="-gt78t0_203">
       DisposeStablePointer
      </code>
      is called to release a reference to a Kotlin object, and
      <code class="code" id="-gt78t0_204">
       DisposeString
      </code>
      is called to release a Kotlin string, which has the
      <code class="code" id="-gt78t0_205">
       char*
      </code>
      type in C.
     </p>
     <p id="-gt78t0_196">
      The next part of the
      <code class="code" id="-gt78t0_206">
       libnative_api.h
      </code>
      file consists of structure declarations of runtime functions:
     </p>
     <div class="code-block" data-lang="c">
      libnative_KBoolean (*IsInstance)(libnative_KNativePtr ref, const libnative_KType* type);
libnative_KBoolean (*IsInstance)(libnative_KNativePtr ref, const libnative_KType* type);
libnative_kref_kotlin_Byte (*createNullableByte)(libnative_KByte);
libnative_KByte (*getNonNullValueOfByte)(libnative_kref_kotlin_Byte);
libnative_kref_kotlin_Short (*createNullableShort)(libnative_KShort);
libnative_KShort (*getNonNullValueOfShort)(libnative_kref_kotlin_Short);
libnative_kref_kotlin_Int (*createNullableInt)(libnative_KInt);
libnative_KInt (*getNonNullValueOfInt)(libnative_kref_kotlin_Int);
libnative_kref_kotlin_Long (*createNullableLong)(libnative_KLong);
libnative_KLong (*getNonNullValueOfLong)(libnative_kref_kotlin_Long);
libnative_kref_kotlin_Float (*createNullableFloat)(libnative_KFloat);
libnative_KFloat (*getNonNullValueOfFloat)(libnative_kref_kotlin_Float);
libnative_kref_kotlin_Double (*createNullableDouble)(libnative_KDouble);
libnative_KDouble (*getNonNullValueOfDouble)(libnative_kref_kotlin_Double);
libnative_kref_kotlin_Char (*createNullableChar)(libnative_KChar);
libnative_KChar (*getNonNullValueOfChar)(libnative_kref_kotlin_Char);
libnative_kref_kotlin_Boolean (*createNullableBoolean)(libnative_KBoolean);
libnative_KBoolean (*getNonNullValueOfBoolean)(libnative_kref_kotlin_Boolean);
libnative_kref_kotlin_Unit (*createNullableUnit)(void);
libnative_kref_kotlin_UByte (*createNullableUByte)(libnative_KUByte);
libnative_KUByte (*getNonNullValueOfUByte)(libnative_kref_kotlin_UByte);
libnative_kref_kotlin_UShort (*createNullableUShort)(libnative_KUShort);
libnative_KUShort (*getNonNullValueOfUShort)(libnative_kref_kotlin_UShort);
libnative_kref_kotlin_UInt (*createNullableUInt)(libnative_KUInt);
libnative_KUInt (*getNonNullValueOfUInt)(libnative_kref_kotlin_UInt);
libnative_kref_kotlin_ULong (*createNullableULong)(libnative_KULong);
libnative_KULong (*getNonNullValueOfULong)(libnative_kref_kotlin_ULong);
     </div>
     <p id="-gt78t0_198">
      You can use the
      <code class="code" id="-gt78t0_207">
       IsInstance
      </code>
      function to check if a Kotlin object (referenced with its
      <code class="code" id="-gt78t0_208">
       .pinned
      </code>
      pointer) is an instance of a type. The actual set of operations generated depends on actual usages.
     </p>
     <aside class="prompt" data-title="" data-type="tip" id="-gt78t0_199">
      <p id="-gt78t0_209">
       Kotlin/Native has its own garbage collector, but it doesn't manage Kotlin objects accessed from C. However, Kotlin/Native provides
       <a data-tooltip="The Objective-C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from Objective-C libraries should have the @ExperimentalForeignApi annotation." href="native-objc-interop.html" id="-gt78t0_210">
        interoperability with Swift/Objective-C
       </a>
       , and the garbage collector is
       <a data-tooltip="Kotlin and Objective-C use different memory management strategies. Kotlin has a tracing garbage collector, while Objective-C relies on automatic reference counting (ARC)." href="native-arc-integration.html" id="-gt78t0_211">
        integrated with Swift/Objective-C ARC
       </a>
       .
      </p>
     </aside>
    </section>
    <section class="chapter">
     <h3 data-toc="your-library-functions" id="your-library-functions">
      Your library functions
     </h3>
     <p id="-gt78t0_212">
      Let's take a look at the separate structure declarations used in your library. The
      <code class="code" id="-gt78t0_221">
       libnative_kref_example
      </code>
      field mimics the package structure of your Kotlin code with a
      <code class="code" id="-gt78t0_222">
       libnative_kref.
      </code>
      prefix:
     </p>
     <div class="code-block" data-lang="c">
      typedef struct {
  /* User functions. */
  struct {
    struct {
      struct {
        struct {
          libnative_KType* (*_type)(void);
          libnative_kref_example_Object (*_instance)();
          const char* (*get_field)(libnative_kref_example_Object thiz);
        } Object;
        struct {
          libnative_KType* (*_type)(void);
          libnative_kref_example_Clazz (*Clazz)();
          libnative_KULong (*memberFunction)(libnative_kref_example_Clazz thiz, libnative_KInt p);
        } Clazz;
        const char* (*get_globalString)();
        void (*forFloats)(libnative_KFloat f, libnative_KDouble d);
        void (*forIntegers)(libnative_KByte b, libnative_KShort s, libnative_KUInt i, libnative_KLong l);
        const char* (*strings)(const char* str);
      } example;
    } root;
  } kotlin;
} libnative_ExportedSymbols;
     </div>
     <p id="-gt78t0_214">
      The code uses anonymous structure declarations. Here,
      <code class="code" id="-gt78t0_223">
       struct { ... } foo
      </code>
      declares a field in the outer struct of the anonymous structure type, which has no name.
     </p>
     <p id="-gt78t0_215">
      Since C doesn't support objects either, function pointers are used to mimic object semantics. A function pointer is declared as
      <code class="code" id="-gt78t0_224">
       RETURN_TYPE (* FIELD_NAME)(PARAMETERS)
      </code>
      .
     </p>
     <p id="-gt78t0_216">
      The
      <code class="code" id="-gt78t0_225">
       libnative_kref_example_Clazz
      </code>
      field represents the
      <code class="code" id="-gt78t0_226">
       Clazz
      </code>
      from Kotlin. The
      <code class="code" id="-gt78t0_227">
       libnative_KULong
      </code>
      is accessible with the
      <code class="code" id="-gt78t0_228">
       memberFunction
      </code>
      field. The only difference is that the
      <code class="code" id="-gt78t0_229">
       memberFunction
      </code>
      accepts a
      <code class="code" id="-gt78t0_230">
       thiz
      </code>
      reference as the first parameter. Since C doesn't support objects, the
      <code class="code" id="-gt78t0_231">
       thiz
      </code>
      pointer is passed explicitly.
     </p>
     <p id="-gt78t0_217">
      There is a constructor in the
      <code class="code" id="-gt78t0_232">
       Clazz
      </code>
      field (aka
      <code class="code" id="-gt78t0_233">
       libnative_kref_example_Clazz_Clazz
      </code>
      ), which acts as the constructor function to create an instance of the
      <code class="code" id="-gt78t0_234">
       Clazz
      </code>
      .
     </p>
     <p id="-gt78t0_218">
      The Kotlin
      <code class="code" id="-gt78t0_235">
       object Object
      </code>
      is accessible as
      <code class="code" id="-gt78t0_236">
       libnative_kref_example_Object
      </code>
      . The
      <code class="code" id="-gt78t0_237">
       _instance
      </code>
      function retrieves the only instance of the object.
     </p>
     <p id="-gt78t0_219">
      Properties are translated into functions. The
      <code class="code" id="-gt78t0_238">
       get_
      </code>
      and
      <code class="code" id="-gt78t0_239">
       set_
      </code>
      prefixes name the getter and the setter functions, respectively. For example, the read-only property
      <code class="code" id="-gt78t0_240">
       globalString
      </code>
      from Kotlin is turned into a
      <code class="code" id="-gt78t0_241">
       get_globalString
      </code>
      function in C.
     </p>
     <p id="-gt78t0_220">
      Global functions
      <code class="code" id="-gt78t0_242">
       forFloats
      </code>
      ,
      <code class="code" id="-gt78t0_243">
       forIntegers
      </code>
      , and
      <code class="code" id="-gt78t0_244">
       strings
      </code>
      are turned into functions pointers in the
      <code class="code" id="-gt78t0_245">
       libnative_kref_example
      </code>
      anonymous struct.
     </p>
    </section>
    <section class="chapter">
     <h3 data-toc="entry-point" id="entry-point">
      Entry point
     </h3>
     <p id="-gt78t0_246">
      Now you know how the API is created, the initialization of the
      <code class="code" id="-gt78t0_250">
       libnative_ExportedSymbols
      </code>
      structure is the starting point. Let's then take a look at the final part of the
      <code class="code" id="-gt78t0_251">
       libnative_api.h
      </code>
      :
     </p>
     <div class="code-block" data-lang="c">
      extern libnative_ExportedSymbols* libnative_symbols(void);
     </div>
     <p id="-gt78t0_248">
      The
      <code class="code" id="-gt78t0_252">
       libnative_symbols
      </code>
      function allows you to open the gateway from the native code to the Kotlin/Native library. This is the entry point for accessing the library. The library name is used as a prefix for the function name.
     </p>
     <aside class="prompt" data-title="" data-type="note" id="-gt78t0_249">
      <p id="-gt78t0_253">
       It might be necessary to host the returned
       <code class="code" id="-gt78t0_254">
        libnative_ExportedSymbols*
       </code>
       pointer per thread.
      </p>
     </aside>
    </section>
   </section>
   <section class="chapter">
    <h2 data-toc="use-generated-headers-from-c" id="use-generated-headers-from-c">
     Use generated headers from C
    </h2>
    <p id="-gt78t0_255">
     Using the generated headers from C is straightforward. In the library directory, create the
     <code class="code" id="-gt78t0_257">
      main.c
     </code>
     file with the following code:
    </p>
    <div class="code-block" data-lang="c">
     #include "libnative_api.h"
#include "stdio.h"

int main(int argc, char** argv) {
  // Obtain reference for calling Kotlin/Native functions
  libnative_ExportedSymbols* lib = libnative_symbols();

  lib-&gt;kotlin.root.example.forIntegers(1, 2, 3, 4);
  lib-&gt;kotlin.root.example.forFloats(1.0f, 2.0);

  // Use C and Kotlin/Native strings
  const char* str = "Hello from Native!";
  const char* response = lib-&gt;kotlin.root.example.strings(str);
  printf("in: %s\nout:%s\n", str, response);
  lib-&gt;DisposeString(response);

  // Create Kotlin object instance
  libnative_kref_example_Clazz newInstance = lib-&gt;kotlin.root.example.Clazz.Clazz();
  long x = lib-&gt;kotlin.root.example.Clazz.memberFunction(newInstance, 42);
  lib-&gt;DisposeStablePointer(newInstance.pinned);

  printf("DemoClazz returned %ld\n", x);

  return 0;
}
    </div>
   </section>
   <section class="chapter">
    <h2 data-toc="compile-and-run-the-project" id="compile-and-run-the-project">
     Compile and run the project
    </h2>
    <section class="chapter">
     <h3 data-toc="on-macos" id="on-macos">
      On macOS
     </h3>
     <p id="-gt78t0_261">
      To compile the C code and link it with the dynamic library, navigate to the library directory and run the following command:
     </p>
     <div class="code-block" data-lang="bash">
      clang main.c libnative.dylib
     </div>
     <p id="-gt78t0_263">
      The compiler generates an executable called
      <code class="code" id="-gt78t0_264">
       a.out
      </code>
      . Run it to execute the Kotlin code from the C library.
     </p>
    </section>
    <section class="chapter">
     <h3 data-toc="on-linux" id="on-linux">
      On Linux
     </h3>
     <p id="-gt78t0_265">
      To compile the C code and link it with the dynamic library, navigate to the library directory and run the following command:
     </p>
     <div class="code-block" data-lang="bash">
      gcc main.c libnative.so
     </div>
     <p id="-gt78t0_267">
      The compiler generates an executable called
      <code class="code" id="-gt78t0_268">
       a.out
      </code>
      . Run it to execute the Kotlin code from the C library. On Linux, you need to include
      <code class="code" id="-gt78t0_269">
       .
      </code>
      into the
      <code class="code" id="-gt78t0_270">
       LD_LIBRARY_PATH
      </code>
      to let the application know to load the
      <code class="code" id="-gt78t0_271">
       libnative.so
      </code>
      library from the current folder.
     </p>
    </section>
    <section class="chapter">
     <h3 data-toc="on-windows" id="on-windows">
      On Windows
     </h3>
     <p id="-gt78t0_272">
      First, you'll need to install a Microsoft Visual C++ compiler that supports the x64_64 target.
     </p>
     <p id="-gt78t0_273">
      The easiest way to do this is to install Microsoft Visual Studio on a Windows machine. During installation, select the necessary components to work with C++, for example,
      <span class="control" id="-gt78t0_277">
       Desktop development with C++
      </span>
      .
     </p>
     <p id="-gt78t0_274">
      On Windows, you can include dynamic libraries either by generating a static library wrapper or manually with the
      <a data-external="true" href="https://learn.microsoft.com/en-gb/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya" id="-gt78t0_278" rel="noopener noreferrer">
       LoadLibrary
      </a>
      or similar Win32API functions.
     </p>
     <p id="-gt78t0_275">
      Let's use the first option and generate the static wrapper library for the
      <code class="code" id="-gt78t0_279">
       libnative.dll
      </code>
      :
     </p>
     <ol class="list _decimal" id="-gt78t0_276" type="1">
      <li class="list__item" id="-gt78t0_280">
       <p id="-gt78t0_282">
        Call
        <code class="code" id="-gt78t0_284">
         lib.exe
        </code>
        from the toolchain to generate the static library wrapper
        <code class="code" id="-gt78t0_285">
         libnative.lib
        </code>
        that automates the DLL usage from the code:
       </p>
       <div class="code-block" data-lang="bash">
        lib /def:libnative.def /out:libnative.lib
       </div>
      </li>
      <li class="list__item" id="-gt78t0_281">
       <p id="-gt78t0_286">
        Compile your
        <code class="code" id="-gt78t0_289">
         main.c
        </code>
        into an executable. Include the generated
        <code class="code" id="-gt78t0_290">
         libnative.lib
        </code>
        into the build command and start:
       </p>
       <div class="code-block" data-lang="bash">
        cl.exe main.c libnative.lib
       </div>
       <p id="-gt78t0_288">
        The command produces the
        <code class="code" id="-gt78t0_291">
         main.exe
        </code>
        file, which you can run.
       </p>
      </li>
     </ol>
    </section>
   </section>
   <section class="chapter">
    <h2 data-toc="what-s-next" id="what-s-next">
     What's next
    </h2>
    <ul class="list _bullet" id="-gt78t0_292">
     <li class="list__item" id="-gt78t0_293">
      <p>
       <a data-tooltip="The Objective-C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from Objective-C libraries should have the @ExperimentalForeignApi annotation." href="native-objc-interop.html" id="-gt78t0_295">
        Learn more about interoperability with Swift/Objective-C
       </a>
      </p>
     </li>
     <li class="list__item" id="-gt78t0_294">
      <p>
       <a data-tooltip="The Objective-C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from Objective-C libraries should have the @ExperimentalForeignApi annotation." href="apple-framework.html" id="-gt78t0_296">
        Check out the Kotlin/Native as an Apple framework tutorial
       </a>
      </p>
     </li>
    </ul>
   </section>
   <div class="last-modified">
    Last modified: 16 December 2024
   </div>
   <div data-feedback-placeholder="true">
   </div>
  </div>
 </body>
</html>
