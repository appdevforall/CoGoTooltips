<html>
 <head>
  <meta charset="utf-8"/>
  <link href="doc_style.css" rel="stylesheet"/>
 </head>
 <body>
  <a class="menu-link" href="toc.html">
   MENU
  </a>
  <hr/>
  <div class="article-content">
   <h1 data-toc="collection-parts" id="collection-parts.md">
    Retrieve collection parts
   </h1>
   <p id="-8n1ncg_2">
    The Kotlin standard library contains extension functions for retrieving parts of a collection. These functions provide a variety of ways to select elements for the result collection: listing their positions explicitly, specifying the result size, and others.
   </p>
   <section class="chapter">
    <h2 data-toc="slice" id="slice">
     Slice
    </h2>
    <p id="-8n1ncg_7">
     <a data-external="true" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/slice.html" id="-8n1ncg_9" rel="noopener noreferrer">
      <code class="code" id="-8n1ncg_11">
       slice()
      </code>
     </a>
     returns a list of the collection elements with given indices. The indices may be passed either as a
     <a data-tooltip="Kotlin lets you easily create ranges of values using the .rangeTo() and .rangeUntil() functions from the kotlin.ranges package." href="ranges.html" id="-8n1ncg_10">
      range
     </a>
     or as a collection of integer values.
    </p>
    <div class="code-block" data-lang="kotlin" data-min-compiler-version="1.3" data-runnable="true">
     fun main() {
//sampleStart    
    val numbers = listOf("one", "two", "three", "four", "five", "six")    
    println(numbers.slice(1..3))
    println(numbers.slice(0..4 step 2))
    println(numbers.slice(setOf(3, 5, 0)))    
//sampleEnd
}
    </div>
   </section>
   <section class="chapter">
    <h2 data-toc="take-and-drop" id="take-and-drop">
     Take and drop
    </h2>
    <p id="-8n1ncg_12">
     To get the specified number of elements starting from the first, use the
     <a data-external="true" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/take.html" id="-8n1ncg_18" rel="noopener noreferrer">
      <code class="code" id="-8n1ncg_20">
       take()
      </code>
     </a>
     function. For getting the last elements, use
     <a data-external="true" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/take-last.html" id="-8n1ncg_19" rel="noopener noreferrer">
      <code class="code" id="-8n1ncg_21">
       takeLast()
      </code>
     </a>
     . When called with a number larger than the collection size, both functions return the whole collection.
    </p>
    <p id="-8n1ncg_13">
     To take all the elements except a given number of first or last elements, call the
     <a data-external="true" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/drop.html" id="-8n1ncg_22" rel="noopener noreferrer">
      <code class="code" id="-8n1ncg_24">
       drop()
      </code>
     </a>
     and
     <a data-external="true" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/drop-last.html" id="-8n1ncg_23" rel="noopener noreferrer">
      <code class="code" id="-8n1ncg_25">
       dropLast()
      </code>
     </a>
     functions respectively.
    </p>
    <div class="code-block" data-lang="kotlin" data-min-compiler-version="1.3" data-runnable="true">
     fun main() {
//sampleStart
    val numbers = listOf("one", "two", "three", "four", "five", "six")
    println(numbers.take(3))
    println(numbers.takeLast(3))
    println(numbers.drop(1))
    println(numbers.dropLast(5))
//sampleEnd
}
    </div>
    <p id="-8n1ncg_15">
     You can also use predicates to define the number of elements for taking or dropping. There are four functions similar to the ones described above:
    </p>
    <ul class="list _bullet" id="-8n1ncg_16">
     <li class="list__item" id="-8n1ncg_26">
      <p>
       <a data-external="true" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/take-while.html" id="-8n1ncg_30" rel="noopener noreferrer">
        <code class="code" id="-8n1ncg_32">
         takeWhile()
        </code>
       </a>
       is
       <code class="code" id="-8n1ncg_31">
        take()
       </code>
       with a predicate: it takes the elements up to but excluding the first one not matching the predicate. If the first collection element doesn't match the predicate, the result is empty.
      </p>
     </li>
     <li class="list__item" id="-8n1ncg_27">
      <p>
       <a data-external="true" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/take-last-while.html" id="-8n1ncg_33" rel="noopener noreferrer">
        <code class="code" id="-8n1ncg_35">
         takeLastWhile()
        </code>
       </a>
       is similar to
       <code class="code" id="-8n1ncg_34">
        takeLast()
       </code>
       : it takes the range of elements matching the predicate from the end of the collection. The first element of the range is the element next to the last element not matching the predicate. If the last collection element doesn't match the predicate, the result is empty;
      </p>
     </li>
     <li class="list__item" id="-8n1ncg_28">
      <p>
       <a data-external="true" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/drop-while.html" id="-8n1ncg_36" rel="noopener noreferrer">
        <code class="code" id="-8n1ncg_38">
         dropWhile()
        </code>
       </a>
       is the opposite to
       <code class="code" id="-8n1ncg_37">
        takeWhile()
       </code>
       with the same predicate: it returns the elements from the first one not matching the predicate to the end.
      </p>
     </li>
     <li class="list__item" id="-8n1ncg_29">
      <p>
       <a data-external="true" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/drop-last-while.html" id="-8n1ncg_39" rel="noopener noreferrer">
        <code class="code" id="-8n1ncg_41">
         dropLastWhile()
        </code>
       </a>
       is the opposite to
       <code class="code" id="-8n1ncg_40">
        takeLastWhile()
       </code>
       with the same predicate: it returns the elements from the beginning to the last one not matching the predicate.
      </p>
     </li>
    </ul>
    <div class="code-block" data-lang="kotlin" data-min-compiler-version="1.3" data-runnable="true">
     fun main() {
//sampleStart
    val numbers = listOf("one", "two", "three", "four", "five", "six")
    println(numbers.takeWhile { !it.startsWith('f') })
    println(numbers.takeLastWhile { it != "three" })
    println(numbers.dropWhile { it.length == 3 })
    println(numbers.dropLastWhile { it.contains('i') })
//sampleEnd
}
    </div>
   </section>
   <section class="chapter">
    <h2 data-toc="chunked" id="chunked">
     Chunked
    </h2>
    <p id="-8n1ncg_42">
     To break a collection into parts of a given size, use the
     <a data-external="true" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/chunked.html" id="-8n1ncg_46" rel="noopener noreferrer">
      <code class="code" id="-8n1ncg_52">
       chunked()
      </code>
     </a>
     function.
     <code class="code" id="-8n1ncg_47">
      chunked()
     </code>
     takes a single argument – the size of the chunk – and returns a
     <code class="code" id="-8n1ncg_48">
      List
     </code>
     of
     <code class="code" id="-8n1ncg_49">
      List
     </code>
     s of the given size. The first chunk starts from the first element and contains the
     <code class="code" id="-8n1ncg_50">
      size
     </code>
     elements, the second chunk holds the next
     <code class="code" id="-8n1ncg_51">
      size
     </code>
     elements, and so on. The last chunk may have a smaller size.
    </p>
    <div class="code-block" data-lang="kotlin" data-min-compiler-version="1.3" data-runnable="true">
     fun main() {
//sampleStart
    val numbers = (0..13).toList()
    println(numbers.chunked(3))
//sampleEnd
}
    </div>
    <p id="-8n1ncg_44">
     You can also apply a transformation for the returned chunks right away. To do this, provide the transformation as a lambda function when calling
     <code class="code" id="-8n1ncg_53">
      chunked()
     </code>
     . The lambda argument is a chunk of the collection. When
     <code class="code" id="-8n1ncg_54">
      chunked()
     </code>
     is called with a transformation, the chunks are short-living
     <code class="code" id="-8n1ncg_55">
      List
     </code>
     s that should be consumed right in that lambda.
    </p>
    <div class="code-block" data-lang="kotlin" data-min-compiler-version="1.3" data-runnable="true">
     fun main() {
//sampleStart
    val numbers = (0..13).toList() 
    println(numbers.chunked(3) { it.sum() })  // `it` is a chunk of the original collection
//sampleEnd
}
    </div>
   </section>
   <section class="chapter">
    <h2 data-toc="windowed" id="windowed">
     Windowed
    </h2>
    <p id="-8n1ncg_56">
     You can retrieve all possible ranges of the collection elements of a given size. The function for getting them is called
     <a data-external="true" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/windowed.html" id="-8n1ncg_64" rel="noopener noreferrer">
      <code class="code" id="-8n1ncg_70">
       windowed()
      </code>
     </a>
     : it returns a list of element ranges that you would see if you were looking at the collection through a sliding window of the given size. Unlike
     <code class="code" id="-8n1ncg_65">
      chunked()
     </code>
     ,
     <code class="code" id="-8n1ncg_66">
      windowed()
     </code>
     returns element ranges (
     <span class="emphasis" id="-8n1ncg_67">
      windows
     </span>
     ) starting from
     <span class="emphasis" id="-8n1ncg_68">
      each
     </span>
     collection element. All the windows are returned as elements of a single
     <code class="code" id="-8n1ncg_69">
      List
     </code>
     .
    </p>
    <div class="code-block" data-lang="kotlin" data-min-compiler-version="1.3" data-runnable="true">
     fun main() {
//sampleStart
    val numbers = listOf("one", "two", "three", "four", "five")    
    println(numbers.windowed(3))
//sampleEnd
}
    </div>
    <p id="-8n1ncg_58">
     <code class="code" id="-8n1ncg_71">
      windowed()
     </code>
     provides more flexibility with optional parameters:
    </p>
    <ul class="list _bullet" id="-8n1ncg_59">
     <li class="list__item" id="-8n1ncg_72">
      <p>
       <code class="code" id="-8n1ncg_74">
        step
       </code>
       defines a distance between first elements of two adjacent windows. By default the value is 1, so the result contains windows starting from all elements. If you increase the step to 2, you will receive only windows starting from odd elements: first, third, and so on.
      </p>
     </li>
     <li class="list__item" id="-8n1ncg_73">
      <p>
       <code class="code" id="-8n1ncg_75">
        partialWindows
       </code>
       includes windows of smaller sizes that start from the elements at the end of the collection. For example, if you request windows of three elements, you can't build them for the last two elements. Enabling
       <code class="code" id="-8n1ncg_76">
        partialWindows
       </code>
       in this case includes two more lists of sizes 2 and 1.
      </p>
     </li>
    </ul>
    <p id="-8n1ncg_60">
     Finally, you can apply a transformation to the returned ranges right away. To do this, provide the transformation as a lambda function when calling
     <code class="code" id="-8n1ncg_77">
      windowed()
     </code>
     .
    </p>
    <div class="code-block" data-lang="kotlin" data-min-compiler-version="1.3" data-runnable="true">
     fun main() {
//sampleStart
    val numbers = (1..10).toList()
    println(numbers.windowed(3, step = 2, partialWindows = true))
    println(numbers.windowed(3) { it.sum() })
//sampleEnd
}
    </div>
    <p id="-8n1ncg_62">
     To build two-element windows, there is a separate function -
     <a data-external="true" href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/zip-with-next.html" id="-8n1ncg_78" rel="noopener noreferrer">
      <code class="code" id="-8n1ncg_87">
       zipWithNext()
      </code>
     </a>
     . It creates pairs of adjacent elements of the receiver collection. Note that
     <code class="code" id="-8n1ncg_79">
      zipWithNext()
     </code>
     doesn't break the collection into pairs; it creates a
     <code class="code" id="-8n1ncg_80">
      Pair
     </code>
     for
     <span class="emphasis" id="-8n1ncg_81">
      each
     </span>
     element except the last one, so its result on
     <code class="code" id="-8n1ncg_82">
      [1, 2, 3, 4]
     </code>
     is
     <code class="code" id="-8n1ncg_83">
      [[1, 2], [2, 3], [3, 4]]
     </code>
     , not
     <code class="code" id="-8n1ncg_84">
      [[1, 2
     </code>
     ],
     <code class="code" id="-8n1ncg_85">
      [3, 4]]
     </code>
     .
     <code class="code" id="-8n1ncg_86">
      zipWithNext()
     </code>
     can be called with a transformation function as well; it should take two elements of the receiver collection as arguments.
    </p>
    <div class="code-block" data-lang="kotlin" data-min-compiler-version="1.3" data-runnable="true">
     fun main() {
//sampleStart
    val numbers = listOf("one", "two", "three", "four", "five")    
    println(numbers.zipWithNext())
    println(numbers.zipWithNext() { s1, s2 -&gt; s1.length &gt; s2.length})
//sampleEnd
}
    </div>
   </section>
   <div class="last-modified">
    Last modified: 16 December 2024
   </div>
   <div data-feedback-placeholder="true">
   </div>
  </div>
 </body>
</html>
