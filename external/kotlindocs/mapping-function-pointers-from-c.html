<html>
 <head>
  <meta charset="utf-8"/>
  <link href="doc_style.css" rel="stylesheet"/>
 </head>
 <body>
  <a class="menu-link" href="toc.html">
   MENU
  </a>
  <hr/>
  <div class="article-content">
   <h1 data-toc="mapping-function-pointers-from-c" id="mapping-function-pointers-from-c.md">
    Mapping function pointers from C – tutorial
   </h1>
   <aside class="prompt" data-title="" data-type="warning" id="z3075a8_2">
    <p id="z3075a8_13">
     The C libraries import is
     <a data-tooltip="Here's a quick guide to these stability levels and their meaning:" href="components-stability.html#stability-levels-explained" id="z3075a8_15">
      Experimental
     </a>
     . All Kotlin declarations generated by the
     <code class="code" id="z3075a8_16">
      cinterop
     </code>
     tool from C libraries should have the
     <code class="code" id="z3075a8_17">
      @ExperimentalForeignApi
     </code>
     annotation.
    </p>
    <p id="z3075a8_14">
     Native platform libraries shipped with Kotlin/Native (like Foundation, UIKit, and POSIX), require opt-in only for some APIs. In such cases, you get an IDE warning.
    </p>
   </aside>
   <p id="z3075a8_3">
    This is the third post in the series. The very first tutorial is
    <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="mapping-primitive-data-types-from-c.html" id="z3075a8_18">
     Mapping primitive data types from C
    </a>
    . There are also
    <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="mapping-struct-union-types-from-c.html" id="z3075a8_19">
     Mapping struct and union types from C
    </a>
    and
    <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="mapping-strings-from-c.html" id="z3075a8_20">
     Mapping strings from C
    </a>
    tutorials.
   </p>
   <p id="z3075a8_4">
    In this tutorial We will learn how to:
   </p>
   <ul class="list _bullet" id="z3075a8_5">
    <li class="list__item" id="z3075a8_21">
     <p>
      <a data-tooltip="It is the time to try using C functions from the Kotlin program. Call the accept_fun function and pass the C function pointer to a Kotlin lambda:" href="#pass-kotlin-function-as-c-function-pointer" id="z3075a8_23">
       Pass Kotlin function as C function pointer
      </a>
     </p>
    </li>
    <li class="list__item" id="z3075a8_22">
     <p>
      <a data-tooltip="The next step is to call a C function pointer from a C pointer that you have from the supply_fun() call:" href="#use-the-c-function-pointer-from-kotlin" id="z3075a8_24">
       Use C function pointer from Kotlin
      </a>
     </p>
    </li>
   </ul>
   <section class="chapter">
    <h2 data-toc="mapping-function-pointer-types-from-c" id="mapping-function-pointer-types-from-c">
     Mapping function pointer types from C
    </h2>
    <p id="z3075a8_25">
     The best way to understand the mapping between Kotlin and C is to try a tiny example. Declare a function that accepts a function pointer as a parameter and another function that returns a function pointer.
    </p>
    <p id="z3075a8_26">
     Kotlin/Native comes with the
     <code class="code" id="z3075a8_30">
      cinterop
     </code>
     tool; the tool generates bindings between the C language and Kotlin. It uses a
     <code class="code" id="z3075a8_31">
      .def
     </code>
     file to specify a C library to import. More details on this are in
     <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="native-c-interop.html" id="z3075a8_32">
      Interop with C Libraries
     </a>
     .
    </p>
    <p id="z3075a8_27">
     The quickest way to try out C API mapping is to have all C declarations in the
     <code class="code" id="z3075a8_33">
      interop.def
     </code>
     file, without creating any
     <code class="code" id="z3075a8_34">
      .h
     </code>
     of
     <code class="code" id="z3075a8_35">
      .c
     </code>
     files at all. Then place the C declarations in a
     <code class="code" id="z3075a8_36">
      .def
     </code>
     file after the special
     <code class="code" id="z3075a8_37">
      ---
     </code>
     separator line:
    </p>
    <div class="code-block" data-lang="c">
     ---

int myFun(int i) {
  return i+1;
}

typedef int  (*MyFun)(int);

void accept_fun(MyFun f) {
  f(42);
}

MyFun supply_fun() {
  return myFun;
}
    </div>
    <p id="z3075a8_29">
     The
     <code class="code" id="z3075a8_38">
      interop.def
     </code>
     file is enough to compile and run the application or open it in an IDE. Now it is time to create project files, open the project in
     <a data-external="true" href="https://jetbrains.com/idea" id="z3075a8_39" rel="noopener noreferrer">
      IntelliJ IDEA
     </a>
     and run it.
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="inspect-generated-kotlin-apis-for-a-c-library" id="inspect-generated-kotlin-apis-for-a-c-library">
     Inspect generated Kotlin APIs for a C library
    </h2>
    <p id="z3075a8_40">
     While it is possible to use the command line, either directly or by combining it with a script file (such as
     <code class="code" id="z3075a8_49">
      .sh
     </code>
     or
     <code class="code" id="z3075a8_50">
      .bat
     </code>
     file), this approach doesn't scale well for big projects that have hundreds of files and libraries. It is then better to use the Kotlin/Native compiler with a build system, as it helps to download and cache the Kotlin/Native compiler binaries and libraries with transitive dependencies and run the compiler and tests. Kotlin/Native can use the
     <a data-external="true" href="https://gradle.org" id="z3075a8_51" rel="noopener noreferrer">
      Gradle
     </a>
     build system through the
     <a data-tooltip="Projects targeting multiple platforms, called multiplatform projects, require the kotlin-multiplatform plugin." href="gradle-configure-project.html#targeting-multiple-platforms" id="z3075a8_52">
      kotlin-multiplatform
     </a>
     plugin.
    </p>
    <p id="z3075a8_41">
     We covered the basics of setting up an IDE compatible project with Gradle in the
     <a data-tooltip="In this section, you'll learn how to manually create a Kotlin/Native application using Gradle. It's the default build system for Kotlin/Native and Kotlin Multiplatform projects, which is also commonly used in Java, Android, and other ecosystems." href="native-get-started.html#using-gradle" id="z3075a8_53">
      Get started with Kotlin/Native
     </a>
     tutorial. Please check it out if you are looking for detailed first steps and instructions on how to start a new Kotlin/Native project and open it in IntelliJ IDEA. In this tutorial, we'll look at the advanced C interop related usages of Kotlin/Native and
     <a data-tooltip="Projects targeting multiple platforms, called multiplatform projects, require the kotlin-multiplatform plugin." href="gradle-configure-project.html#targeting-multiple-platforms" id="z3075a8_54">
      multiplatform
     </a>
     builds with Gradle.
    </p>
    <p id="z3075a8_42">
     First, create a project folder. All the paths in this tutorial will be relative to this folder. Sometimes the missing directories will have to be created before any new files can be added.
    </p>
    <p id="z3075a8_43">
     Use the following
     <code class="code" id="z3075a8_55">
      build.gradle(.kts)
     </code>
     Gradle build file:
    </p>
    <div class="tabs" data-anchors="[z3075a8_56,z3075a8_57]" data-group="build-script" id="z3075a8_44">
     <div class="tabs__content" data-gtm="tab" data-sync-tabs="kotlin" data-title="Kotlin" id="z3075a8_56">
      <div class="code-block" data-lang="kotlin" data-title="Kotlin">
       plugins {
    kotlin("multiplatform") version "2.1.0"
}

repositories {
    mavenCentral()
}

kotlin {
  linuxX64("native") { // on Linux
  // macosX64("native") { // on x86_64 macOS
  // macosArm64("native") { // on Apple Silicon macOS
  // mingwX64("native") { // on Windows
    val main by compilations.getting
    val interop by main.cinterops.creating
    
    binaries {
      executable()
    }
  }
}

tasks.wrapper {
  gradleVersion = "8.10"
  distributionType = Wrapper.DistributionType.BIN
}
      </div>
     </div>
     <div class="tabs__content" data-gtm="tab" data-sync-tabs="groovy" data-title="Groovy" id="z3075a8_57">
      <div class="code-block" data-lang="groovy" data-title="Groovy">
       plugins {
    id 'org.jetbrains.kotlin.multiplatform' version '2.1.0'
}

repositories {
    mavenCentral()
}

kotlin {
  linuxX64('native') { // on Linux
  // macosX64("native") { // on x86_64 macOS
  // macosArm64("native") { // on Apple Silicon macOS  
  // mingwX64('native') { // on Windows
    compilations.main.cinterops {
      interop 
    }
    
    binaries {
      executable()
    }
  }
}

wrapper {
  gradleVersion = '8.10'
  distributionType = 'BIN'
}
      </div>
     </div>
    </div>
    <p id="z3075a8_45">
     The project file configures the C interop as an additional step of the build. Let's move the
     <code class="code" id="z3075a8_60">
      interop.def
     </code>
     file to the
     <code class="code" id="z3075a8_61">
      src/nativeInterop/cinterop
     </code>
     directory. Gradle recommends using conventions instead of configurations, for example, the source files are expected to be in the
     <code class="code" id="z3075a8_62">
      src/nativeMain/kotlin
     </code>
     folder. By default, all the symbols from C are imported to the
     <code class="code" id="z3075a8_63">
      interop
     </code>
     package, you may want to import the whole package in our
     <code class="code" id="z3075a8_64">
      .kt
     </code>
     files. Check out the
     <a data-tooltip="The Kotlin Multiplatform Gradle plugin is a tool for creating Kotlin Multiplatform projects. Here we provide a reference of its contents; use it as a reminder when writing Gradle build scripts for Kotlin Multiplatform projects. Learn the concepts of Kotlin Multiplatform projects,…" href="multiplatform-dsl-reference.html" id="z3075a8_65">
      Multiplatform Gradle DSL reference
     </a>
     to learn about all the different ways you could configure it.
    </p>
    <p id="z3075a8_46">
     Let's create a
     <code class="code" id="z3075a8_66">
      src/nativeMain/kotlin/hello.kt
     </code>
     stub file with the following content to see how C function pointer declarations are visible from Kotlin:
    </p>
    <div class="code-block" data-lang="kotlin">
     import interop.*

fun main() {
  println("Hello Kotlin/Native!")
  
  accept_fun(https://kotlinlang.org/*fix me */)
  val useMe = supply_fun()
}
    </div>
    <p id="z3075a8_48">
     Now you are ready to
     <a data-tooltip="In this tutorial, you'll learn how to create a Kotlin/Native application. Choose the tool that works best for you and create your app using:" href="native-get-started.html" id="z3075a8_67">
      open the project in IntelliJ IDEA
     </a>
     and to see how to fix the example project. While doing that, see how C functions are mapped into Kotlin/Native declarations.
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="c-function-pointers-in-kotlin" id="c-function-pointers-in-kotlin">
     C function pointers in Kotlin
    </h2>
    <p id="z3075a8_68">
     With the help of IntelliJ IDEA's
     <span class="control" id="z3075a8_71">
      Go To
     </span>
     |
     <span class="control" id="z3075a8_72">
      Declaration or Usages
     </span>
     or compiler errors, see the following declarations for the C functions:
    </p>
    <div class="code-block" data-lang="kotlin">
     fun accept_fun(f: MyFun? /* = CPointer&lt;CFunction&lt;(Int) -&gt; Int&gt;&gt;? */)
fun supply_fun(): MyFun? /* = CPointer&lt;CFunction&lt;(Int) -&gt; Int&gt;&gt;? */

fun myFun(i: kotlin.Int): kotlin.Int

typealias MyFun = kotlinx.cinterop.CPointer&lt;kotlinx.cinterop.CFunction&lt;(kotlin.Int) -&gt; kotlin.Int&gt;&gt;

typealias MyFunVar = kotlinx.cinterop.CPointerVarOf&lt;lib.MyFun&gt;
    </div>
    <p id="z3075a8_70">
     You see that the function's
     <code class="code" id="z3075a8_73">
      typedef
     </code>
     from C has been turned into Kotlin
     <code class="code" id="z3075a8_74">
      typealias
     </code>
     . It uses
     <code class="code" id="z3075a8_75">
      CPointer&lt;..&gt;
     </code>
     type to represent the pointer parameters, and
     <code class="code" id="z3075a8_76">
      CFunction&lt;(Int)-&gt;Int&gt;
     </code>
     to represent the function signature. There is an
     <code class="code" id="z3075a8_77">
      invoke
     </code>
     operator extension function available for all
     <code class="code" id="z3075a8_78">
      CPointer&lt;CFunction&lt;..&gt;
     </code>
     types, so that it is possible to call it as you would call any other function in Kotlin.
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="pass-kotlin-function-as-c-function-pointer" id="pass-kotlin-function-as-c-function-pointer">
     Pass Kotlin function as C function pointer
    </h2>
    <p id="z3075a8_79">
     It is the time to try using C functions from the Kotlin program. Call the
     <code class="code" id="z3075a8_83">
      accept_fun
     </code>
     function and pass the C function pointer to a Kotlin lambda:
    </p>
    <div class="code-block" data-lang="kotlin">
     fun myFun() {
  accept_fun(staticCFunction&lt;Int, Int&gt; { it + 1 })
}
    </div>
    <p id="z3075a8_81">
     This call uses the
     <code class="code" id="z3075a8_84">
      staticCFunction{..}
     </code>
     helper function from Kotlin/Native to wrap a Kotlin lambda function into a C function pointer. It only allows having unbound and non-capturing lambda functions. For example, it is not able to use a local variable from the function. You may only use globally visible declarations.
    </p>
    <p id="z3075a8_82">
     It is vital to make sure that the function does not throw any exceptions. Throwing exceptions from a
     <code class="code" id="z3075a8_85">
      staticCFunction{..}
     </code>
     will end up in non-deterministic side-effects.
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="use-the-c-function-pointer-from-kotlin" id="use-the-c-function-pointer-from-kotlin">
     Use the C function pointer from Kotlin
    </h2>
    <p id="z3075a8_86">
     The next step is to call a C function pointer from a C pointer that you have from the
     <code class="code" id="z3075a8_89">
      supply_fun()
     </code>
     call:
    </p>
    <div class="code-block" data-lang="kotlin">
     fun myFun2() {
  val functionFromC = supply_fun() ?: error("No function is returned")
  
  functionFromC(42)
}
    </div>
    <p id="z3075a8_88">
     Kotlin turns the function pointer return type into a nullable
     <code class="code" id="z3075a8_90">
      CPointer&lt;CFunction&lt;..&gt;
     </code>
     object. There is the need to explicitly check for
     <code class="code" id="z3075a8_91">
      null
     </code>
     first. The
     <a data-tooltip="Null safety is a Kotlin feature designed to significantly reduce the risk of null references, also known as The Billion-Dollar Mistake." href="null-safety.html" id="z3075a8_92">
      elvis operator
     </a>
     for that in the code above. The
     <code class="code" id="z3075a8_93">
      cinterop
     </code>
     tool helps us to turn a C function pointer into an easy to call object in Kotlin. This is what we did on the last line.
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="fix-the-code" id="fix-the-code">
     Fix the code
    </h2>
    <p id="z3075a8_94">
     You've seen all definitions and it is time to fix and run the code. Run the
     <code class="code" id="z3075a8_98">
      runDebugExecutableNative
     </code>
     Gradle task
     <a data-tooltip="In this tutorial, you'll learn how to create a Kotlin/Native application. Choose the tool that works best for you and create your app using:" href="native-get-started.html" id="z3075a8_99">
      in the IDE
     </a>
     or use the following command to run the code:
    </p>
    <div class="code-block" data-lang="bash">
     ./gradlew runDebugExecutableNative
    </div>
    <p id="z3075a8_96">
     The code in the
     <code class="code" id="z3075a8_100">
      hello.kt
     </code>
     file may look like this:
    </p>
    <div class="code-block" data-lang="kotlin">
     import interop.*
import kotlinx.cinterop.*

fun main() {
  println("Hello Kotlin/Native!")
 
  val cFunctionPointer = staticCFunction&lt;Int, Int&gt; { it + 1 }
  accept_fun(cFunctionPointer)

  val funFromC = supply_fun() ?: error("No function is returned")
  funFromC(42)
}
    </div>
   </section>
   <section class="chapter">
    <h2 data-toc="next-steps" id="next-steps">
     Next Steps
    </h2>
    <p id="z3075a8_101">
     Continue exploring more C language types and their representation in Kotlin/Native in next tutorials:
    </p>
    <ul class="list _bullet" id="z3075a8_102">
     <li class="list__item" id="z3075a8_104">
      <p>
       <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="mapping-primitive-data-types-from-c.html" id="z3075a8_107">
        Mapping primitive data types from C
       </a>
      </p>
     </li>
     <li class="list__item" id="z3075a8_105">
      <p>
       <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="mapping-struct-union-types-from-c.html" id="z3075a8_108">
        Mapping struct and union types from C
       </a>
      </p>
     </li>
     <li class="list__item" id="z3075a8_106">
      <p>
       <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="mapping-strings-from-c.html" id="z3075a8_109">
        Mapping strings from C
       </a>
      </p>
     </li>
    </ul>
    <p id="z3075a8_103">
     The
     <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="native-c-interop.html" id="z3075a8_110">
      C Interop documentation
     </a>
     covers more advanced scenarios of the interop.
    </p>
   </section>
   <div class="last-modified">
    Last modified: 16 December 2024
   </div>
   <div data-feedback-placeholder="true">
   </div>
  </div>
 </body>
</html>
