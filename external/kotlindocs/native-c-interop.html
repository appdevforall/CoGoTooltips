<html>
 <head>
  <meta charset="utf-8"/>
  <link href="doc_style.css" rel="stylesheet"/>
 </head>
 <body>
  <a class="menu-link" href="toc.html">
   MENU
  </a>
  <hr/>
  <div class="article-content">
   <h1 data-toc="native-c-interop" id="native-c-interop.md">
    Interoperability with C
   </h1>
   <aside class="prompt" data-title="" data-type="warning" id="cvnp44_2">
    <p id="cvnp44_12">
     The C libraries import is
     <a data-tooltip="Here's a quick guide to these stability levels and their meaning:" href="components-stability.html#stability-levels-explained" id="cvnp44_14">
      Experimental
     </a>
     . All Kotlin declarations generated by the cinterop tool from C libraries should have the
     <code class="code" id="cvnp44_15">
      @ExperimentalForeignApi
     </code>
     annotation.
    </p>
    <p id="cvnp44_13">
     Native platform libraries shipped with Kotlin/Native (like Foundation, UIKit, and POSIX), require opt-in only for some APIs. In such cases, you get an IDE warning.
    </p>
   </aside>
   <p id="cvnp44_3">
    Kotlin/Native follows the general tradition of Kotlin to provide excellent existing platform software interoperability. In the case of a native platform, the most important interoperability target is a C library. So Kotlin/Native comes with a cinterop tool, which can be used to quickly generate everything needed to interact with an external library.
   </p>
   <p id="cvnp44_4">
    The following workflow is expected when interacting with the native library:
   </p>
   <ol class="list _decimal" id="cvnp44_5" type="1">
    <li class="list__item" id="cvnp44_16">
     <p>
      Create a
      <code class="code" id="cvnp44_19">
       .def
      </code>
      file describing what to include into bindings.
     </p>
    </li>
    <li class="list__item" id="cvnp44_17">
     <p>
      Use the cinterop tool to produce Kotlin bindings.
     </p>
    </li>
    <li class="list__item" id="cvnp44_18">
     <p>
      Run the Kotlin/Native compiler on an application to produce the final executable.
     </p>
    </li>
   </ol>
   <p id="cvnp44_6">
    The interoperability tool analyses C headers and produces a "natural" mapping of the types, functions, and constants into the Kotlin world. The generated stubs can be imported into an IDE for the purpose of code completion and navigation.
   </p>
   <p id="cvnp44_7">
    Interoperability with Swift/Objective-C is provided too and covered in
    <a data-tooltip="The Objective-C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from Objective-C libraries should have the @ExperimentalForeignApi annotation." href="native-objc-interop.html" id="cvnp44_20">
     Objective-C interop
    </a>
    .
   </p>
   <section class="chapter">
    <h2 data-toc="platform-libraries" id="platform-libraries">
     Platform libraries
    </h2>
    <p id="cvnp44_21">
     Note that in many cases there's no need to use custom interoperability library creation mechanisms described below, as for APIs available on the platform standardized bindings called
     <a data-tooltip="To provide access to user's native operating system services, Kotlin/Native distribution includes a set of prebuilt libraries specific to each target. We call them Platform Libraries." href="native-platform-libs.html" id="cvnp44_22">
      platform libraries
     </a>
     could be used. For example, POSIX on Linux/macOS platforms, Win32 on Windows platform, or Apple frameworks on macOS/iOS are available this way.
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="simple-example" id="simple-example">
     Simple example
    </h2>
    <p id="cvnp44_23">
     Install libgit2 and prepare stubs for the git library:
    </p>
    <div class="code-block" data-lang="bash">
     cd samples/gitchurn
../../dist/bin/cinterop -def src/nativeInterop/cinterop/libgit2.def \
 -compiler-option -I/usr/local/include -o libgit2
    </div>
    <p id="cvnp44_25">
     Compile the client:
    </p>
    <div class="code-block" data-lang="bash">
     ../../dist/bin/kotlinc src/gitChurnMain/kotlin \
 -library libgit2 -o GitChurn
    </div>
    <p id="cvnp44_27">
     Run the client:
    </p>
    <div class="code-block" data-lang="bash">
     ./GitChurn.kexe ../..
    </div>
   </section>
   <section class="chapter">
    <h2 data-toc="create-bindings-for-a-new-library" id="create-bindings-for-a-new-library">
     Create bindings for a new library
    </h2>
    <p id="cvnp44_29">
     To create bindings for a new library, first create and configure a
     <a data-tooltip="Kotlin/Native enables you to consume C and Objective-C libraries, allowing you to use their functionality in Kotlin. A special tool called cinterop takes a C or an Objective-C library and generates the corresponding Kotlin bindings, so that the library's methods can be used in yourâ€¦" href="native-definition-file.html" id="cvnp44_30">
      definition file
     </a>
     .
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="bindings" id="bindings">
     Bindings
    </h2>
    <section class="chapter">
     <h3 data-toc="basic-interop-types" id="basic-interop-types">
      Basic interop types
     </h3>
     <p id="cvnp44_42">
      All the supported C types have corresponding representations in Kotlin:
     </p>
     <ul class="list _bullet" id="cvnp44_43">
      <li class="list__item" id="cvnp44_47">
       <p>
        Signed, unsigned integral, and floating point types are mapped to their Kotlin counterpart with the same width.
       </p>
      </li>
      <li class="list__item" id="cvnp44_48">
       <p>
        Pointers and arrays are mapped to
        <code class="code" id="cvnp44_52">
         CPointer&lt;T&gt;?
        </code>
        .
       </p>
      </li>
      <li class="list__item" id="cvnp44_49">
       <p>
        Enums can be mapped to either Kotlin enum or integral values, depending on heuristics and the
        <a data-tooltip="Use the strictEnums property to generate enums as Kotlin enums or nonStrictEnums to generate them as integral values. If an enum is not included in either of these lists, it is generated based on heuristics." href="native-definition-file.html#configure-enums-generation" id="cvnp44_53">
         definition file settings
        </a>
        .
       </p>
      </li>
      <li class="list__item" id="cvnp44_50">
       <p>
        Structs and unions are mapped to types having fields available via the dot notation, i.e.
        <code class="code" id="cvnp44_54">
         someStructInstance.field1
        </code>
        .
       </p>
      </li>
      <li class="list__item" id="cvnp44_51">
       <p>
        <code class="code" id="cvnp44_55">
         typedef
        </code>
        are represented as
        <code class="code" id="cvnp44_56">
         typealias
        </code>
        .
       </p>
      </li>
     </ul>
     <p id="cvnp44_44">
      Also, any C type has the Kotlin type representing the lvalue of this type, i.e., the value located in memory rather than a simple immutable self-contained value. Think C++ references, as a similar concept. For structs (and
      <code class="code" id="cvnp44_57">
       typedef
      </code>
      s to structs) this representation is the main one and has the same name as the struct itself, for Kotlin enums it is named
      <code class="code" id="cvnp44_58">
       ${type}Var
      </code>
      , for
      <code class="code" id="cvnp44_59">
       CPointer&lt;T&gt;
      </code>
      it is
      <code class="code" id="cvnp44_60">
       CPointerVar&lt;T&gt;
      </code>
      , and for most other types it is
      <code class="code" id="cvnp44_61">
       ${type}Var
      </code>
      .
     </p>
     <p id="cvnp44_45">
      For types that have both representations, the one with a "lvalue" has a mutable
      <code class="code" id="cvnp44_62">
       .value
      </code>
      property for accessing the value.
     </p>
     <section class="chapter">
      <h4 data-toc="pointer-types" id="pointer-types">
       Pointer types
      </h4>
      <p id="cvnp44_63">
       The type argument
       <code class="code" id="cvnp44_78">
        T
       </code>
       of
       <code class="code" id="cvnp44_79">
        CPointer&lt;T&gt;
       </code>
       must be one of the "lvalue" types described above, e.g., the C type
       <code class="code" id="cvnp44_80">
        struct S*
       </code>
       is mapped to
       <code class="code" id="cvnp44_81">
        CPointer&lt;S&gt;
       </code>
       ,
       <code class="code" id="cvnp44_82">
        int8_t*
       </code>
       is mapped to
       <code class="code" id="cvnp44_83">
        CPointer&lt;int_8tVar&gt;
       </code>
       , and
       <code class="code" id="cvnp44_84">
        char**
       </code>
       is mapped to
       <code class="code" id="cvnp44_85">
        CPointer&lt;CPointerVar&lt;ByteVar&gt;&gt;
       </code>
       .
      </p>
      <p id="cvnp44_64">
       C null pointer is represented as Kotlin's
       <code class="code" id="cvnp44_86">
        null
       </code>
       , and the pointer type
       <code class="code" id="cvnp44_87">
        CPointer&lt;T&gt;
       </code>
       is not nullable, but the
       <code class="code" id="cvnp44_88">
        CPointer&lt;T&gt;?
       </code>
       is. The values of this type support all the Kotlin operations related to handling
       <code class="code" id="cvnp44_89">
        null
       </code>
       , e.g.
       <code class="code" id="cvnp44_90">
        ?:
       </code>
       ,
       <code class="code" id="cvnp44_91">
        ?.
       </code>
       ,
       <code class="code" id="cvnp44_92">
        !!
       </code>
       etc.:
      </p>
      <div class="code-block" data-lang="kotlin">
       val path = getenv("PATH")?.toKString() ?: ""
      </div>
      <p id="cvnp44_66">
       Since the arrays are also mapped to
       <code class="code" id="cvnp44_93">
        CPointer&lt;T&gt;
       </code>
       , it supports the
       <code class="code" id="cvnp44_94">
        []
       </code>
       operator for accessing values by index:
      </p>
      <div class="code-block" data-lang="kotlin">
       import kotlinx.cinterop.*

@OptIn(ExperimentalForeignApi::class)
fun shift(ptr: CPointer&lt;ByteVar&gt;, length: Int) {
    for (index in 0 .. length - 2) {
        ptr[index] = ptr[index + 1]
    }
}
      </div>
      <p id="cvnp44_68">
       The
       <code class="code" id="cvnp44_95">
        .pointed
       </code>
       property for
       <code class="code" id="cvnp44_96">
        CPointer&lt;T&gt;
       </code>
       returns the lvalue of type
       <code class="code" id="cvnp44_97">
        T
       </code>
       , pointed by this pointer. The reverse operation is
       <code class="code" id="cvnp44_98">
        .ptr
       </code>
       : it takes the lvalue and returns the pointer to it.
      </p>
      <p id="cvnp44_69">
       <code class="code" id="cvnp44_99">
        void*
       </code>
       is mapped to
       <code class="code" id="cvnp44_100">
        COpaquePointer
       </code>
       â€“ the special pointer type which is the supertype for any other pointer type. So if the C function takes
       <code class="code" id="cvnp44_101">
        void*
       </code>
       , then the Kotlin binding accepts any
       <code class="code" id="cvnp44_102">
        CPointer
       </code>
       .
      </p>
      <p id="cvnp44_70">
       Casting a pointer (including
       <code class="code" id="cvnp44_103">
        COpaquePointer
       </code>
       ) can be done with
       <code class="code" id="cvnp44_104">
        .reinterpret&lt;T&gt;
       </code>
       , e.g.:
      </p>
      <div class="code-block" data-lang="kotlin">
       import kotlinx.cinterop.*

@OptIn(ExperimentalForeignApi::class)
val intPtr = bytePtr.reinterpret&lt;IntVar&gt;()
      </div>
      <p id="cvnp44_72">
       or
      </p>
      <div class="code-block" data-lang="kotlin">
       import kotlinx.cinterop.*

@OptIn(ExperimentalForeignApi::class)
val intPtr: CPointer&lt;IntVar&gt; = bytePtr.reinterpret()
      </div>
      <p id="cvnp44_74">
       As is with C, these reinterpret casts are unsafe and can potentially lead to subtle memory problems in the application.
      </p>
      <p id="cvnp44_75">
       Also, there are unsafe casts between
       <code class="code" id="cvnp44_105">
        CPointer&lt;T&gt;?
       </code>
       and
       <code class="code" id="cvnp44_106">
        Long
       </code>
       available, provided by the
       <code class="code" id="cvnp44_107">
        .toLong()
       </code>
       and
       <code class="code" id="cvnp44_108">
        .toCPointer&lt;T&gt;()
       </code>
       extension methods:
      </p>
      <div class="code-block" data-lang="kotlin">
       val longValue = ptr.toLong()
val originalPtr = longValue.toCPointer&lt;T&gt;()
      </div>
      <p id="cvnp44_77">
       Note that if the type of the result is known from the context, the type argument can be omitted as usual due to the type inference.
      </p>
     </section>
    </section>
    <section class="chapter">
     <h3 data-toc="memory-allocation" id="memory-allocation">
      Memory allocation
     </h3>
     <p id="cvnp44_109">
      The native memory can be allocated using the
      <code class="code" id="cvnp44_118">
       NativePlacement
      </code>
      interface, for example:
     </p>
     <div class="code-block" data-lang="kotlin">
      import kotlinx.cinterop.*

@OptIn(ExperimentalForeignApi::class)
val byteVar = placement.alloc&lt;ByteVar&gt;()
     </div>
     <p id="cvnp44_111">
      or
     </p>
     <div class="code-block" data-lang="kotlin">
      import kotlinx.cinterop.*

@OptIn(ExperimentalForeignApi::class)
val bytePtr = placement.allocArray&lt;ByteVar&gt;(5)
     </div>
     <p id="cvnp44_113">
      The most "natural" placement is in the object
      <code class="code" id="cvnp44_119">
       nativeHeap
      </code>
      . It corresponds to allocating native memory with
      <code class="code" id="cvnp44_120">
       malloc
      </code>
      and provides an additional
      <code class="code" id="cvnp44_121">
       .free()
      </code>
      operation to free allocated memory:
     </p>
     <div class="code-block" data-lang="kotlin">
      import kotlinx.cinterop.*

@OptIn(kotlinx.cinterop.ExperimentalForeignApi::class)
fun main() {
    val size: Long = 0
    val buffer = nativeHeap.allocArray&lt;ByteVar&gt;(size)
    nativeHeap.free(buffer)
}
     </div>
     <p id="cvnp44_115">
      However, the lifetime of allocated memory is often bound to the lexical scope. It is possible to define such scope with
      <code class="code" id="cvnp44_122">
       memScoped { ... }
      </code>
      . Inside the braces, the temporary placement is available as an implicit receiver, so it is possible to allocate native memory with
      <code class="code" id="cvnp44_123">
       alloc
      </code>
      and
      <code class="code" id="cvnp44_124">
       allocArray
      </code>
      , and the allocated memory will be automatically freed after leaving the scope.
     </p>
     <p id="cvnp44_116">
      For example, the C function returning values through pointer parameters can be used like:
     </p>
     <div class="code-block" data-lang="kotlin">
      import kotlinx.cinterop.*
import platform.posix.*

@OptIn(ExperimentalForeignApi::class)
val fileSize = memScoped {
    val statBuf = alloc&lt;stat&gt;()
    val error = stat("/", statBuf.ptr)
    statBuf.st_size
}
     </div>
    </section>
    <section class="chapter">
     <h3 data-toc="pass-pointers-to-bindings" id="pass-pointers-to-bindings">
      Pass pointers to bindings
     </h3>
     <p id="cvnp44_125">
      Although C pointers are mapped to the
      <code class="code" id="cvnp44_131">
       CPointer&lt;T&gt;
      </code>
      type, the C function pointer-typed parameters are mapped to
      <code class="code" id="cvnp44_132">
       CValuesRef&lt;T&gt;
      </code>
      . When passing
      <code class="code" id="cvnp44_133">
       CPointer&lt;T&gt;
      </code>
      as the value of such a parameter, it is passed to the C function as is. However, the sequence of values can be passed instead of a pointer. In this case the sequence is passed "by value", i.e., the C function receives the pointer to the temporary copy of that sequence, which is valid only until the function returns.
     </p>
     <p id="cvnp44_126">
      The
      <code class="code" id="cvnp44_134">
       CValuesRef&lt;T&gt;
      </code>
      representation of pointer parameters is designed to support C array literals without explicit native memory allocation. To construct the immutable self-contained sequence of C values, the following methods are provided:
     </p>
     <ul class="list _bullet" id="cvnp44_127">
      <li class="list__item" id="cvnp44_135">
       <p>
        <code class="code" id="cvnp44_138">
         ${type}Array.toCValues()
        </code>
        , where
        <code class="code" id="cvnp44_139">
         type
        </code>
        is the Kotlin primitive type
       </p>
      </li>
      <li class="list__item" id="cvnp44_136">
       <p>
        <code class="code" id="cvnp44_140">
         Array&lt;CPointer&lt;T&gt;?&gt;.toCValues()
        </code>
        ,
        <code class="code" id="cvnp44_141">
         List&lt;CPointer&lt;T&gt;?&gt;.toCValues()
        </code>
       </p>
      </li>
      <li class="list__item" id="cvnp44_137">
       <p>
        <code class="code" id="cvnp44_142">
         cValuesOf(vararg elements: ${type})
        </code>
        , where
        <code class="code" id="cvnp44_143">
         type
        </code>
        is a primitive or pointer
       </p>
      </li>
     </ul>
     <p id="cvnp44_128">
      For example:
     </p>
     <div class="code-block" data-lang="c">
      // C:
void foo(int* elements, int count);
...
int elements[] = {1, 2, 3};
foo(elements, 3);
     </div>
     <div class="code-block" data-lang="kotlin">
      // Kotlin:

foo(cValuesOf(1, 2, 3), 3)
     </div>
    </section>
    <section class="chapter">
     <h3 data-toc="strings" id="strings">
      Strings
     </h3>
     <p id="cvnp44_144">
      Unlike other pointers, the parameters of type
      <code class="code" id="cvnp44_154">
       const char*
      </code>
      are represented as a Kotlin
      <code class="code" id="cvnp44_155">
       String
      </code>
      . So it is possible to pass any Kotlin string to a binding expecting a C string.
     </p>
     <p id="cvnp44_145">
      There are also some tools available to convert between Kotlin and C strings manually:
     </p>
     <ul class="list _bullet" id="cvnp44_146">
      <li class="list__item" id="cvnp44_156">
       <p>
        <code class="code" id="cvnp44_158">
         fun CPointer&lt;ByteVar&gt;.toKString(): String
        </code>
       </p>
      </li>
      <li class="list__item" id="cvnp44_157">
       <p>
        <code class="code" id="cvnp44_159">
         val String.cstr: CValuesRef&lt;ByteVar&gt;
        </code>
        .
       </p>
      </li>
     </ul>
     <p id="cvnp44_147">
      To get the pointer,
      <code class="code" id="cvnp44_160">
       .cstr
      </code>
      should be allocated in native memory, for example:
     </p>
     <div class="code-block" data-lang="kotlin">
      val cString = kotlinString.cstr.getPointer(nativeHeap)
     </div>
     <p id="cvnp44_149">
      In all cases, the C string is supposed to be encoded as UTF-8.
     </p>
     <p id="cvnp44_150">
      To skip automatic conversion and ensure raw pointers are used in the bindings, a
      <code class="code" id="cvnp44_161">
       noStringConversion
      </code>
      statement in the
      <code class="code" id="cvnp44_162">
       .def
      </code>
      file could be used:
     </p>
     <div class="code-block" data-lang="c">
      noStringConversion = LoadCursorA LoadCursorW
     </div>
     <p id="cvnp44_152">
      This way any value of type
      <code class="code" id="cvnp44_163">
       CPointer&lt;ByteVar&gt;
      </code>
      can be passed as an argument of
      <code class="code" id="cvnp44_164">
       const char*
      </code>
      type. If a Kotlin string should be passed, code like this could be used:
     </p>
     <div class="code-block" data-lang="kotlin">
      import kotlinx.cinterop.*

@OptIn(kotlinx.cinterop.ExperimentalForeignApi::class)
memScoped {
    LoadCursorA(null, "cursor.bmp".cstr.ptr)   // for ASCII version
    LoadCursorW(null, "cursor.bmp".wcstr.ptr)  // for Unicode version
}
     </div>
    </section>
    <section class="chapter">
     <h3 data-toc="scope-local-pointers" id="scope-local-pointers">
      Scope-local pointers
     </h3>
     <p id="cvnp44_165">
      It is possible to create a scope-stable pointer of C representation of
      <code class="code" id="cvnp44_168">
       CValues&lt;T&gt;
      </code>
      instance using the
      <code class="code" id="cvnp44_169">
       CValues&lt;T&gt;.ptr
      </code>
      extension property, available under
      <code class="code" id="cvnp44_170">
       memScoped { }
      </code>
      . It allows using the APIs which require C pointers with a lifetime bound to a certain
      <code class="code" id="cvnp44_171">
       MemScope
      </code>
      . For example:
     </p>
     <div class="code-block" data-lang="kotlin">
      import kotlinx.cinterop.*

@OptIn(kotlinx.cinterop.ExperimentalForeignApi::class)
memScoped {
    items = arrayOfNulls&lt;CPointer&lt;ITEM&gt;?&gt;(6)
    arrayOf("one", "two").forEachIndexed { index, value -&gt; items[index] = value.cstr.ptr }
    menu = new_menu("Menu".cstr.ptr, items.toCValues().ptr)
    // ...
}
     </div>
     <p id="cvnp44_167">
      In this example, all values passed to the C API
      <code class="code" id="cvnp44_172">
       new_menu()
      </code>
      have a lifetime of the innermost
      <code class="code" id="cvnp44_173">
       memScope
      </code>
      it belongs to. Once the control flow leaves the
      <code class="code" id="cvnp44_174">
       memScoped
      </code>
      scope the C pointers become invalid.
     </p>
    </section>
    <section class="chapter">
     <h3 data-toc="pass-and-receive-structs-by-value" id="pass-and-receive-structs-by-value">
      Pass and receive structs by value
     </h3>
     <p id="cvnp44_175">
      When a C function takes or returns a struct / union
      <code class="code" id="cvnp44_178">
       T
      </code>
      by value, the corresponding argument type or return type is represented as
      <code class="code" id="cvnp44_179">
       CValue&lt;T&gt;
      </code>
      .
     </p>
     <p id="cvnp44_176">
      <code class="code" id="cvnp44_180">
       CValue&lt;T&gt;
      </code>
      is an opaque type, so the structure fields cannot be accessed with the appropriate Kotlin properties. It should be possible, if an API uses structures as handles, but if field access is required, there are the following conversion methods available:
     </p>
     <ul class="list _bullet" id="cvnp44_177">
      <li class="list__item" id="cvnp44_181">
       <p id="cvnp44_183">
        <code class="code" id="cvnp44_184">
         fun T.readValue(): CValue&lt;T&gt;
        </code>
        . Converts (the lvalue)
        <code class="code" id="cvnp44_185">
         T
        </code>
        to a
        <code class="code" id="cvnp44_186">
         CValue&lt;T&gt;
        </code>
        . So to construct the
        <code class="code" id="cvnp44_187">
         CValue&lt;T&gt;
        </code>
        ,
        <code class="code" id="cvnp44_188">
         T
        </code>
        can be allocated, filled, and then converted to
        <code class="code" id="cvnp44_189">
         CValue&lt;T&gt;
        </code>
        .
       </p>
      </li>
      <li class="list__item" id="cvnp44_182">
       <p id="cvnp44_190">
        <code class="code" id="cvnp44_192">
         CValue&lt;T&gt;.useContents(block: T.() -&gt; R): R
        </code>
        . Temporarily places the
        <code class="code" id="cvnp44_193">
         CValue&lt;T&gt;
        </code>
        to memory, and then runs the passed lambda with this placed value
        <code class="code" id="cvnp44_194">
         T
        </code>
        as receiver. So to read a single field, the following code can be used:
       </p>
       <div class="code-block" data-lang="kotlin">
        val fieldValue = structValue.useContents { field }
       </div>
      </li>
     </ul>
    </section>
    <section class="chapter">
     <h3 data-toc="callbacks" id="callbacks">
      Callbacks
     </h3>
     <p id="cvnp44_195">
      To convert a Kotlin function to a pointer to a C function,
      <code class="code" id="cvnp44_197">
       staticCFunction(::kotlinFunction)
      </code>
      can be used. It is also able to provide the lambda instead of a function reference. The function or lambda must not capture any values.
     </p>
     <section class="chapter">
      <h4 data-toc="pass-user-data-to-callbacks" id="pass-user-data-to-callbacks">
       Pass user data to callbacks
      </h4>
      <p id="cvnp44_198">
       Often C APIs allow passing some user data to callbacks. Such data is usually provided by the user when configuring the callback. It is passed to some C function (or written to the struct) as e.g.
       <code class="code" id="cvnp44_209">
        void*
       </code>
       . However, references to Kotlin objects can't be directly passed to C. So they require wrapping before configuring the callback and then unwrapping in the callback itself, to safely swim from Kotlin to Kotlin through the C world. Such wrapping is possible with
       <code class="code" id="cvnp44_210">
        StableRef
       </code>
       class.
      </p>
      <p id="cvnp44_199">
       To wrap the reference:
      </p>
      <div class="code-block" data-lang="kotlin">
       import kotlinx.cinterop.*

@OptIn(ExperimentalForeignApi::class)
val stableRef = StableRef.create(kotlinReference)
val voidPtr = stableRef.asCPointer()
      </div>
      <p id="cvnp44_201">
       where the
       <code class="code" id="cvnp44_211">
        voidPtr
       </code>
       is a
       <code class="code" id="cvnp44_212">
        COpaquePointer
       </code>
       and can be passed to the C function.
      </p>
      <p id="cvnp44_202">
       To unwrap the reference:
      </p>
      <div class="code-block" data-lang="kotlin">
       @OptIn(ExperimentalForeignApi::class)
val stableRef = voidPtr.asStableRef&lt;KotlinClass&gt;()
val kotlinReference = stableRef.get()
      </div>
      <p id="cvnp44_204">
       where
       <code class="code" id="cvnp44_213">
        kotlinReference
       </code>
       is the original wrapped reference.
      </p>
      <p id="cvnp44_205">
       The created
       <code class="code" id="cvnp44_214">
        StableRef
       </code>
       should eventually be manually disposed using the
       <code class="code" id="cvnp44_215">
        .dispose()
       </code>
       method to prevent memory leaks:
      </p>
      <div class="code-block" data-lang="kotlin">
       stableRef.dispose()
      </div>
      <p id="cvnp44_207">
       After that it becomes invalid, so
       <code class="code" id="cvnp44_216">
        voidPtr
       </code>
       can't be unwrapped anymore.
      </p>
      <p id="cvnp44_208">
       See the
       <code class="code" id="cvnp44_217">
        samples/libcurl
       </code>
       for more details.
      </p>
     </section>
    </section>
    <section class="chapter">
     <h3 data-toc="macros" id="macros">
      Macros
     </h3>
     <p id="cvnp44_218">
      Every C macro that expands to a constant is represented as a Kotlin property. Other macros are not supported. However, they can be exposed manually by wrapping them with supported declarations. E.g. function-like macro
      <code class="code" id="cvnp44_220">
       FOO
      </code>
      can be exposed as function
      <code class="code" id="cvnp44_221">
       foo
      </code>
      by
      <a data-tooltip="Sometimes it is required to add custom C declarations to the library before generating bindings (for example, for macros). Instead of creating an additional header file with these declarations, you can include them directly to the end of the .def file, after a separating line,â€¦" href="native-definition-file.html#add-custom-declarations" id="cvnp44_222">
       adding the custom declaration
      </a>
      to the library:
     </p>
     <div class="code-block" data-lang="c">
      headers = library/base.h

---

static inline int foo(int arg) {
    return FOO(arg);
}
     </div>
    </section>
    <section class="chapter">
     <h3 data-toc="portability" id="portability">
      Portability
     </h3>
     <p id="cvnp44_223">
      Sometimes the C libraries have function parameters or struct fields of a platform-dependent type, e.g.
      <code class="code" id="cvnp44_230">
       long
      </code>
      or
      <code class="code" id="cvnp44_231">
       size_t
      </code>
      . Kotlin itself doesn't provide neither implicit integer casts nor C-style integer casts (e.g.
      <code class="code" id="cvnp44_232">
       (size_t) intValue
      </code>
      ), so to make writing portable code in such cases easier, the
      <code class="code" id="cvnp44_233">
       convert
      </code>
      method is provided:
     </p>
     <div class="code-block" data-lang="kotlin">
      fun ${type1}.convert&lt;${type2}&gt;(): ${type2}
     </div>
     <p id="cvnp44_225">
      where each of
      <code class="code" id="cvnp44_234">
       type1
      </code>
      and
      <code class="code" id="cvnp44_235">
       type2
      </code>
      must be an integral type, either signed or unsigned.
     </p>
     <p id="cvnp44_226">
      <code class="code" id="cvnp44_236">
       .convert&lt;${type}&gt;
      </code>
      has the same semantics as one of the
      <code class="code" id="cvnp44_237">
       .toByte
      </code>
      ,
      <code class="code" id="cvnp44_238">
       .toShort
      </code>
      ,
      <code class="code" id="cvnp44_239">
       .toInt
      </code>
      ,
      <code class="code" id="cvnp44_240">
       .toLong
      </code>
      ,
      <code class="code" id="cvnp44_241">
       .toUByte
      </code>
      ,
      <code class="code" id="cvnp44_242">
       .toUShort
      </code>
      ,
      <code class="code" id="cvnp44_243">
       .toUInt
      </code>
      or
      <code class="code" id="cvnp44_244">
       .toULong
      </code>
      methods, depending on
      <code class="code" id="cvnp44_245">
       type
      </code>
      .
     </p>
     <p id="cvnp44_227">
      The example of using
      <code class="code" id="cvnp44_246">
       convert
      </code>
      :
     </p>
     <div class="code-block" data-lang="kotlin">
      import kotlinx.cinterop.*
import platform.posix.*

@OptIn(ExperimentalForeignApi::class)
fun zeroMemory(buffer: COpaquePointer, size: Int) {
    memset(buffer, 0, size.convert&lt;size_t&gt;())
}
     </div>
     <p id="cvnp44_229">
      Also, the type parameter can be inferred automatically and so may be omitted in some cases.
     </p>
    </section>
    <section class="chapter">
     <h3 data-toc="object-pinning" id="object-pinning">
      Object pinning
     </h3>
     <p id="cvnp44_247">
      Kotlin objects could be pinned, i.e. their position in memory is guaranteed to be stable until unpinned, and pointers to such objects inner data could be passed to the C functions. For example
     </p>
     <div class="code-block" data-lang="kotlin">
      import kotlinx.cinterop.*
import platform.posix.*

@OptIn(ExperimentalForeignApi::class)
fun readData(fd: Int) {
    val buffer = ByteArray(1024)
    buffer.usePinned { pinned -&gt;
        while (true) {
            val length = recv(fd, pinned.addressOf(0), buffer.size.convert(), 0).toInt()

            if (length &lt;= 0) {
               break
            }
            // Now `buffer` has raw data obtained from the `recv()` call.
        }
    }
}
     </div>
     <p id="cvnp44_249">
      Here we use service function
      <code class="code" id="cvnp44_250">
       usePinned
      </code>
      , which pins an object, executes block and unpins it on normal and exception paths.
     </p>
    </section>
    <section class="chapter">
     <h3 data-toc="forward-declarations" id="forward-declarations">
      Forward declarations
     </h3>
     <p id="cvnp44_251">
      To import forward declarations, use the
      <code class="code" id="cvnp44_257">
       cnames
      </code>
      package. For example, to import a
      <code class="code" id="cvnp44_258">
       cstructName
      </code>
      forward declaration declared in a C library with a
      <code class="code" id="cvnp44_259">
       library.package
      </code>
      , use a special forward declaration package:
      <code class="code" id="cvnp44_260">
       import cnames.structs.cstructName
      </code>
      .
     </p>
     <p id="cvnp44_252">
      Consider two cinterop libraries: one that has a forward declaration of a struct and another with an actual implementation in another package:
     </p>
     <div class="code-block" data-lang="c">
      // First C library
#include &lt;stdio.h&gt;

struct ForwardDeclaredStruct;

void consumeStruct(struct ForwardDeclaredStruct* s) {
    printf("Struct consumed\n");
}
     </div>
     <div class="code-block" data-lang="c">
      // Second C library
// Header:
#include &lt;stdlib.h&gt;

struct ForwardDeclaredStruct {
    int data;
};

// Implementation:
struct ForwardDeclaredStruct* produceStruct() {
    struct ForwardDeclaredStruct* s = malloc(sizeof(struct ForwardDeclaredStruct));
    s-&gt;data = 42;
    return s;
}
     </div>
     <p id="cvnp44_255">
      To transfer objects between the two libraries, use an explicit
      <code class="code" id="cvnp44_261">
       as
      </code>
      cast in you Kotlin code:
     </p>
     <div class="code-block" data-lang="kotlin">
      // Kotlin code:
fun test() {
    consumeStruct(produceStruct() as CPointer&lt;cnames.structs.ForwardDeclaredStruct&gt;)
}
     </div>
    </section>
   </section>
   <div class="last-modified">
    Last modified: 16 December 2024
   </div>
   <div data-feedback-placeholder="true">
   </div>
  </div>
 </body>
</html>
