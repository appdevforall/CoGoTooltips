<html>
 <head>
  <meta charset="utf-8"/>
  <link href="doc_style.css" rel="stylesheet"/>
 </head>
 <body>
  <a class="menu-link" href="toc.html">
   MENU
  </a>
  <hr/>
  <div class="article-content">
   <h1 data-toc="mapping-primitive-data-types-from-c" id="mapping-primitive-data-types-from-c.md">
    Mapping primitive data types from C – tutorial
   </h1>
   <aside class="prompt" data-title="" data-type="warning" id="xwymwn_2">
    <p id="xwymwn_11">
     The C libraries import is
     <a data-tooltip="Here's a quick guide to these stability levels and their meaning:" href="components-stability.html#stability-levels-explained" id="xwymwn_13">
      Experimental
     </a>
     . All Kotlin declarations generated by the
     <code class="code" id="xwymwn_14">
      cinterop
     </code>
     tool from C libraries should have the
     <code class="code" id="xwymwn_15">
      @ExperimentalForeignApi
     </code>
     annotation.
    </p>
    <p id="xwymwn_12">
     Native platform libraries shipped with Kotlin/Native (like Foundation, UIKit, and POSIX), require opt-in only for some APIs. In such cases, you get an IDE warning.
    </p>
   </aside>
   <p id="xwymwn_3">
    In this tutorial, you will learn what C data types are visible in Kotlin/Native and vice versa. You will:
   </p>
   <ul class="list _bullet" id="xwymwn_4">
    <li class="list__item" id="xwymwn_16">
     <p>
      See what
      <a data-tooltip="What types are there in the C language? Let's take the C data types article from Wikipedia as a basis. There are following types in the C programming language:" href="#types-in-c-language" id="xwymwn_20">
       Data types are in C language
      </a>
      .
     </p>
    </li>
    <li class="list__item" id="xwymwn_17">
     <p>
      Create a
      <a data-tooltip="Create a lib.h file to see how C functions are mapped into Kotlin:" href="#example-c-library" id="xwymwn_21">
       tiny C Library
      </a>
      that uses those types in exports.
     </p>
    </li>
    <li class="list__item" id="xwymwn_18">
     <p>
      <a data-tooltip="While it is possible to use the command line, either directly or by combining it with a script file (such as .sh or .bat file), this approach doesn't scale well for big projects that have hundreds of files and libraries. It is then better to use the Kotlin/Native compiler with a…" href="#inspect-generated-kotlin-apis-for-a-c-library" id="xwymwn_22">
       Inspect generated Kotlin APIs from a C library
      </a>
      .
     </p>
    </li>
    <li class="list__item" id="xwymwn_19">
     <p>
      Find how
      <a data-tooltip="With the help of IntelliJ IDEA's Go to | Declaration or compiler errors, you see the following generated API for the C functions:" href="#primitive-types-in-kotlin" id="xwymwn_23">
       Primitive types in Kotlin
      </a>
      are mapped to C.
     </p>
    </li>
   </ul>
   <section class="chapter">
    <h2 data-toc="types-in-c-language" id="types-in-c-language">
     Types in C language
    </h2>
    <p id="xwymwn_24">
     What types are there in the C language? Let's take the
     <a data-external="true" href="https://en.wikipedia.org/wiki/C_data_types" id="xwymwn_30" rel="noopener noreferrer">
      C data types
     </a>
     article from Wikipedia as a basis. There are following types in the C programming language:
    </p>
    <ul class="list _bullet" id="xwymwn_25">
     <li class="list__item" id="xwymwn_31">
      <p>
       basic types
       <code class="code" id="xwymwn_35">
        char, int, float, double
       </code>
       with modifiers
       <code class="code" id="xwymwn_36">
        signed, unsigned, short, long
       </code>
      </p>
     </li>
     <li class="list__item" id="xwymwn_32">
      <p>
       structures, unions, arrays
      </p>
     </li>
     <li class="list__item" id="xwymwn_33">
      <p>
       pointers
      </p>
     </li>
     <li class="list__item" id="xwymwn_34">
      <p>
       function pointers
      </p>
     </li>
    </ul>
    <p id="xwymwn_26">
     There are also more specific types:
    </p>
    <ul class="list _bullet" id="xwymwn_27">
     <li class="list__item" id="xwymwn_37">
      <p>
       boolean type (from
       <a data-external="true" href="https://en.wikipedia.org/wiki/C99" id="xwymwn_40" rel="noopener noreferrer">
        C99
       </a>
       )
      </p>
     </li>
     <li class="list__item" id="xwymwn_38">
      <p>
       <code class="code" id="xwymwn_41">
        size_t
       </code>
       and
       <code class="code" id="xwymwn_42">
        ptrdiff_t
       </code>
       (also
       <code class="code" id="xwymwn_43">
        ssize_t
       </code>
       )
      </p>
     </li>
     <li class="list__item" id="xwymwn_39">
      <p>
       fixed width integer types, such as
       <code class="code" id="xwymwn_44">
        int32_t
       </code>
       or
       <code class="code" id="xwymwn_45">
        uint64_t
       </code>
       (from
       <a data-external="true" href="https://en.wikipedia.org/wiki/C99" id="xwymwn_46" rel="noopener noreferrer">
        C99
       </a>
       )
      </p>
     </li>
    </ul>
    <p id="xwymwn_28">
     There are also the following type qualifiers in the C language:
     <code class="code" id="xwymwn_47">
      const
     </code>
     ,
     <code class="code" id="xwymwn_48">
      volatile
     </code>
     ,
     <code class="code" id="xwymwn_49">
      restrict
     </code>
     ,
     <code class="code" id="xwymwn_50">
      atomic
     </code>
     .
    </p>
    <p id="xwymwn_29">
     The best way to see what C data types are visible in Kotlin is to try it.
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="example-c-library" id="example-c-library">
     Example C library
    </h2>
    <p id="xwymwn_51">
     Create a
     <code class="code" id="xwymwn_59">
      lib.h
     </code>
     file to see how C functions are mapped into Kotlin:
    </p>
    <div class="code-block" data-lang="c">
     #ifndef LIB2_H_INCLUDED
#define LIB2_H_INCLUDED

void ints(char c, short d, int e, long f);
void uints(unsigned char c, unsigned short d, unsigned int e, unsigned long f);
void doubles(float a, double b);

#endif
    </div>
    <p id="xwymwn_53">
     The file is missing the
     <code class="code" id="xwymwn_60">
      extern "C"
     </code>
     block, which is not needed for this example, but may be necessary if you use C++ and overloaded functions. The
     <a data-external="true" href="https://stackoverflow.com/questions/1041866/what-is-the-effect-of-extern-c-in-c" id="xwymwn_61" rel="noopener noreferrer">
      C++ compatibility thread
     </a>
     on Stackoverflow contains more details on this.
    </p>
    <p id="xwymwn_54">
     For every set of
     <code class="code" id="xwymwn_62">
      .h
     </code>
     files, you will be using the
     <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="native-c-interop.html" id="xwymwn_63">
      <code class="code" id="xwymwn_71">
       cinterop
      </code>
      tool
     </a>
     from Kotlin/Native to generate a Kotlin/Native library, or
     <code class="code" id="xwymwn_64">
      .klib
     </code>
     . The generated library will bridge calls from Kotlin/Native to C. It includes respective Kotlin declarations for the definitions form the
     <code class="code" id="xwymwn_65">
      .h
     </code>
     files. It is only necessary to have a
     <code class="code" id="xwymwn_66">
      .h
     </code>
     file to run the
     <code class="code" id="xwymwn_67">
      cinterop
     </code>
     tool. And you do not need to create a
     <code class="code" id="xwymwn_68">
      lib.c
     </code>
     file, unless you want to compile and run the example. More details on this are covered in the
     <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="native-c-interop.html" id="xwymwn_69">
      C interop
     </a>
     page. It is enough for the tutorial to create the
     <code class="code" id="xwymwn_70">
      lib.def
     </code>
     file with the following content:
    </p>
    <div class="code-block" data-lang="c">
     headers = lib.h
    </div>
    <p id="xwymwn_56">
     You may include all declarations directly into the
     <code class="code" id="xwymwn_72">
      .def
     </code>
     file after a
     <code class="code" id="xwymwn_73">
      ---
     </code>
     separator. It can be helpful to include macros or other C defines into the code generated by the
     <code class="code" id="xwymwn_74">
      cinterop
     </code>
     tool. Method bodies are compiled and fully included into the binary too. Use that feature to have a runnable example without a need for a C compiler. To implement that, you need to add implementations to the C functions from the
     <code class="code" id="xwymwn_75">
      lib.h
     </code>
     file, and place these functions into a
     <code class="code" id="xwymwn_76">
      .def
     </code>
     file. You will have the following
     <code class="code" id="xwymwn_77">
      interop.def
     </code>
     result:
    </p>
    <div class="code-block" data-lang="c">
     ---

void ints(char c, short d, int e, long f) { }
void uints(unsigned char c, unsigned short d, unsigned int e, unsigned long f) { }
void doubles(float a, double b) { }
    </div>
    <p id="xwymwn_58">
     The
     <code class="code" id="xwymwn_78">
      interop.def
     </code>
     file is enough to compile and run the application or open it in an IDE. Now it is time to create project files, open the project in
     <a data-external="true" href="https://jetbrains.com/idea" id="xwymwn_79" rel="noopener noreferrer">
      IntelliJ IDEA
     </a>
     and run it.
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="inspect-generated-kotlin-apis-for-a-c-library" id="inspect-generated-kotlin-apis-for-a-c-library">
     Inspect generated Kotlin APIs for a C library
    </h2>
    <p id="xwymwn_80">
     While it is possible to use the command line, either directly or by combining it with a script file (such as
     <code class="code" id="xwymwn_89">
      .sh
     </code>
     or
     <code class="code" id="xwymwn_90">
      .bat
     </code>
     file), this approach doesn't scale well for big projects that have hundreds of files and libraries. It is then better to use the Kotlin/Native compiler with a build system, as it helps to download and cache the Kotlin/Native compiler binaries and libraries with transitive dependencies and run the compiler and tests. Kotlin/Native can use the
     <a data-external="true" href="https://gradle.org" id="xwymwn_91" rel="noopener noreferrer">
      Gradle
     </a>
     build system through the
     <a data-tooltip="Projects targeting multiple platforms, called multiplatform projects, require the kotlin-multiplatform plugin." href="gradle-configure-project.html#targeting-multiple-platforms" id="xwymwn_92">
      kotlin-multiplatform
     </a>
     plugin.
    </p>
    <p id="xwymwn_81">
     We covered the basics of setting up an IDE compatible project with Gradle in the
     <a data-tooltip="In this section, you'll learn how to manually create a Kotlin/Native application using Gradle. It's the default build system for Kotlin/Native and Kotlin Multiplatform projects, which is also commonly used in Java, Android, and other ecosystems." href="native-get-started.html#using-gradle" id="xwymwn_93">
      Get started with Kotlin/Native
     </a>
     tutorial. Please check it out if you are looking for detailed first steps and instructions on how to start a new Kotlin/Native project and open it in IntelliJ IDEA. In this tutorial, we'll look at the advanced C interop related usages of Kotlin/Native and
     <a data-tooltip="Projects targeting multiple platforms, called multiplatform projects, require the kotlin-multiplatform plugin." href="gradle-configure-project.html#targeting-multiple-platforms" id="xwymwn_94">
      multiplatform
     </a>
     builds with Gradle.
    </p>
    <p id="xwymwn_82">
     First, create a project folder. All the paths in this tutorial will be relative to this folder. Sometimes the missing directories will have to be created before any new files can be added.
    </p>
    <p id="xwymwn_83">
     Use the following
     <code class="code" id="xwymwn_95">
      build.gradle(.kts)
     </code>
     Gradle build file:
    </p>
    <div class="tabs" data-anchors="[xwymwn_96,xwymwn_97]" data-group="build-script" id="xwymwn_84">
     <div class="tabs__content" data-gtm="tab" data-sync-tabs="kotlin" data-title="Kotlin" id="xwymwn_96">
      <div class="code-block" data-lang="kotlin" data-title="Kotlin">
       plugins {
    kotlin("multiplatform") version "2.1.0"
}

repositories {
    mavenCentral()
}

kotlin {
  linuxX64("native") { // on Linux
  // macosX64("native") { // on x86_64 macOS
  // macosArm64("native") { // on Apple Silicon macOS
  // mingwX64("native") { // on Windows
    val main by compilations.getting
    val interop by main.cinterops.creating
    
    binaries {
      executable()
    }
  }
}

tasks.wrapper {
  gradleVersion = "8.10"
  distributionType = Wrapper.DistributionType.BIN
}
      </div>
     </div>
     <div class="tabs__content" data-gtm="tab" data-sync-tabs="groovy" data-title="Groovy" id="xwymwn_97">
      <div class="code-block" data-lang="groovy" data-title="Groovy">
       plugins {
    id 'org.jetbrains.kotlin.multiplatform' version '2.1.0'
}

repositories {
    mavenCentral()
}

kotlin {
  linuxX64('native') { // on Linux
  // macosX64("native") { // on x86_64 macOS
  // macosArm64("native") { // on Apple Silicon macOS
  // mingwX64('native') { // on Windows
    compilations.main.cinterops {
      interop 
    }
    
    binaries {
      executable()
    }
  }
}

wrapper {
  gradleVersion = '8.10'
  distributionType = 'BIN'
}
      </div>
     </div>
    </div>
    <p id="xwymwn_85">
     The project file configures the C interop as an additional step of the build. Let's move the
     <code class="code" id="xwymwn_100">
      interop.def
     </code>
     file to the
     <code class="code" id="xwymwn_101">
      src/nativeInterop/cinterop
     </code>
     directory. Gradle recommends using conventions instead of configurations, for example, the source files are expected to be in the
     <code class="code" id="xwymwn_102">
      src/nativeMain/kotlin
     </code>
     folder. By default, all the symbols from C are imported to the
     <code class="code" id="xwymwn_103">
      interop
     </code>
     package, you may want to import the whole package in our
     <code class="code" id="xwymwn_104">
      .kt
     </code>
     files. Check out the
     <a data-tooltip="The Kotlin Multiplatform Gradle plugin is a tool for creating Kotlin Multiplatform projects. Here we provide a reference of its contents; use it as a reminder when writing Gradle build scripts for Kotlin Multiplatform projects. Learn the concepts of Kotlin Multiplatform projects,…" href="multiplatform-dsl-reference.html" id="xwymwn_105">
      Multiplatform Gradle DSL reference
     </a>
     to learn about all the different ways you could configure it.
    </p>
    <p id="xwymwn_86">
     Create a
     <code class="code" id="xwymwn_106">
      src/nativeMain/kotlin/hello.kt
     </code>
     stub file with the following content to see how C primitive type declarations are visible from Kotlin:
    </p>
    <div class="code-block" data-lang="kotlin">
     import interop.*

fun main() {
  println("Hello Kotlin/Native!")
  
  ints(/* fix me*/)
  uints(/* fix me*/)
  doubles(/* fix me*/)
}
    </div>
    <p id="xwymwn_88">
     Now you are ready to
     <a data-tooltip="In this tutorial, you'll learn how to create a Kotlin/Native application. Choose the tool that works best for you and create your app using:" href="native-get-started.html" id="xwymwn_107">
      open the project in IntelliJ IDEA
     </a>
     and to see how to fix the example project. While doing that, see how C primitive types are mapped into Kotlin/Native.
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="primitive-types-in-kotlin" id="primitive-types-in-kotlin">
     Primitive types in kotlin
    </h2>
    <p id="xwymwn_108">
     With the help of IntelliJ IDEA's
     <span class="control" id="xwymwn_112">
      Go to | Declaration
     </span>
     or compiler errors, you see the following generated API for the C functions:
    </p>
    <div class="code-block" data-lang="kotlin">
     fun ints(c: Byte, d: Short, e: Int, f: Long)
fun uints(c: UByte, d: UShort, e: UInt, f: ULong)
fun doubles(a: Float, b: Double)
    </div>
    <p id="xwymwn_110">
     C types are mapped in the way we would expect, note that
     <code class="code" id="xwymwn_113">
      char
     </code>
     type is mapped to
     <code class="code" id="xwymwn_114">
      kotlin.Byte
     </code>
     as it is usually an 8-bit signed value.
    </p>
    <div class="table-wrapper">
     <table class="wide" id="xwymwn_111">
      <thead>
       <tr class="ijRowHead" id="xwymwn_115">
        <th id="xwymwn_126">
         <p>
          C
         </p>
        </th>
        <th id="xwymwn_127">
         <p>
          Kotlin
         </p>
        </th>
       </tr>
      </thead>
      <tbody>
       <tr id="xwymwn_116">
        <td id="xwymwn_128">
         <p>
          char
         </p>
        </td>
        <td id="xwymwn_129">
         <p>
          kotlin.Byte
         </p>
        </td>
       </tr>
       <tr id="xwymwn_117">
        <td id="xwymwn_130">
         <p>
          unsigned char
         </p>
        </td>
        <td id="xwymwn_131">
         <p>
          kotlin.UByte
         </p>
        </td>
       </tr>
       <tr id="xwymwn_118">
        <td id="xwymwn_132">
         <p>
          short
         </p>
        </td>
        <td id="xwymwn_133">
         <p>
          kotlin.Short
         </p>
        </td>
       </tr>
       <tr id="xwymwn_119">
        <td id="xwymwn_134">
         <p>
          unsigned short
         </p>
        </td>
        <td id="xwymwn_135">
         <p>
          kotlin.UShort
         </p>
        </td>
       </tr>
       <tr id="xwymwn_120">
        <td id="xwymwn_136">
         <p>
          int
         </p>
        </td>
        <td id="xwymwn_137">
         <p>
          kotlin.Int
         </p>
        </td>
       </tr>
       <tr id="xwymwn_121">
        <td id="xwymwn_138">
         <p>
          unsigned int
         </p>
        </td>
        <td id="xwymwn_139">
         <p>
          kotlin.UInt
         </p>
        </td>
       </tr>
       <tr id="xwymwn_122">
        <td id="xwymwn_140">
         <p>
          long long
         </p>
        </td>
        <td id="xwymwn_141">
         <p>
          kotlin.Long
         </p>
        </td>
       </tr>
       <tr id="xwymwn_123">
        <td id="xwymwn_142">
         <p>
          unsigned long long
         </p>
        </td>
        <td id="xwymwn_143">
         <p>
          kotlin.ULong
         </p>
        </td>
       </tr>
       <tr id="xwymwn_124">
        <td id="xwymwn_144">
         <p>
          float
         </p>
        </td>
        <td id="xwymwn_145">
         <p>
          kotlin.Float
         </p>
        </td>
       </tr>
       <tr id="xwymwn_125">
        <td id="xwymwn_146">
         <p>
          double
         </p>
        </td>
        <td id="xwymwn_147">
         <p>
          kotlin.Double
         </p>
        </td>
       </tr>
      </tbody>
     </table>
    </div>
   </section>
   <section class="chapter">
    <h2 data-toc="fix-the-code" id="fix-the-code">
     Fix the code
    </h2>
    <p id="xwymwn_148">
     You've seen all definitions and it is the time to fix the code. Run the
     <code class="code" id="xwymwn_152">
      runDebugExecutableNative
     </code>
     Gradle task
     <a data-tooltip="In this tutorial, you'll learn how to create a Kotlin/Native application. Choose the tool that works best for you and create your app using:" href="native-get-started.html" id="xwymwn_153">
      in IDE
     </a>
     or use the following command to run the code:
    </p>
    <div class="code-block" data-lang="bash">
     ./gradlew runDebugExecutableNative
    </div>
    <p id="xwymwn_150">
     The final code in the
     <code class="code" id="xwymwn_154">
      hello.kt
     </code>
     file may look like that:
    </p>
    <div class="code-block" data-lang="kotlin">
     import interop.*

fun main() {
  println("Hello Kotlin/Native!")
  
  ints(1, 2, 3, 4)
  uints(5, 6, 7, 8)
  doubles(9.0f, 10.0)
}
    </div>
   </section>
   <section class="chapter">
    <h2 data-toc="next-steps" id="next-steps">
     Next steps
    </h2>
    <p id="xwymwn_155">
     Continue to explore more complicated C language types and their representation in Kotlin/Native in the next tutorials:
    </p>
    <ul class="list _bullet" id="xwymwn_156">
     <li class="list__item" id="xwymwn_158">
      <p>
       <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="mapping-struct-union-types-from-c.html" id="xwymwn_161">
        Mapping struct and union types from C
       </a>
      </p>
     </li>
     <li class="list__item" id="xwymwn_159">
      <p>
       <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="mapping-function-pointers-from-c.html" id="xwymwn_162">
        Mapping function pointers from C
       </a>
      </p>
     </li>
     <li class="list__item" id="xwymwn_160">
      <p>
       <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="mapping-strings-from-c.html" id="xwymwn_163">
        Mapping strings from C
       </a>
      </p>
     </li>
    </ul>
    <p id="xwymwn_157">
     The
     <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="native-c-interop.html" id="xwymwn_164">
      C interop documentation
     </a>
     covers more advanced scenarios of the interop.
    </p>
   </section>
   <div class="last-modified">
    Last modified: 16 December 2024
   </div>
   <div data-feedback-placeholder="true">
   </div>
  </div>
 </body>
</html>
