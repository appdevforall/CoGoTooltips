<html>
 <head>
  <meta charset="utf-8"/>
  <link href="doc_style.css" rel="stylesheet"/>
 </head>
 <body>
  <a class="menu-link" href="toc.html">
   MENU
  </a>
  <hr/>
  <div class="article-content">
   <h1 data-toc="numbers" id="numbers.md">
    Numbers
   </h1>
   <section class="chapter">
    <h2 data-toc="integer-types" id="integer-types">
     Integer types
    </h2>
    <p id="-lztin5_8">
     Kotlin provides a set of built-in types that represent numbers.
     <br/>
     For integer numbers, there are four types with different sizes and, hence, value ranges:
    </p>
    <div class="table-wrapper">
     <table class="wide" id="-lztin5_9">
      <thead>
       <tr class="ijRowHead" id="-lztin5_14">
        <th id="-lztin5_19">
         <p>
          Type
         </p>
        </th>
        <th id="-lztin5_20">
         <p>
          Size (bits)
         </p>
        </th>
        <th id="-lztin5_21">
         <p>
          Min value
         </p>
        </th>
        <th id="-lztin5_22">
         <p>
          Max value
         </p>
        </th>
       </tr>
      </thead>
      <tbody>
       <tr id="-lztin5_15">
        <td id="-lztin5_23">
         <p>
          <code class="code" id="-lztin5_27">
           Byte
          </code>
         </p>
        </td>
        <td id="-lztin5_24">
         <p>
          8
         </p>
        </td>
        <td id="-lztin5_25">
         <p>
          -128
         </p>
        </td>
        <td id="-lztin5_26">
         <p>
          127
         </p>
        </td>
       </tr>
       <tr id="-lztin5_16">
        <td id="-lztin5_28">
         <p>
          <code class="code" id="-lztin5_32">
           Short
          </code>
         </p>
        </td>
        <td id="-lztin5_29">
         <p>
          16
         </p>
        </td>
        <td id="-lztin5_30">
         <p>
          -32768
         </p>
        </td>
        <td id="-lztin5_31">
         <p>
          32767
         </p>
        </td>
       </tr>
       <tr id="-lztin5_17">
        <td id="-lztin5_33">
         <p>
          <code class="code" id="-lztin5_37">
           Int
          </code>
         </p>
        </td>
        <td id="-lztin5_34">
         <p>
          32
         </p>
        </td>
        <td id="-lztin5_35">
         <p>
          -2,147,483,648 (-2
          <sup class="superscript" id="-lztin5_38">
           31
          </sup>
          )
         </p>
        </td>
        <td id="-lztin5_36">
         <p>
          2,147,483,647 (2
          <sup class="superscript" id="-lztin5_39">
           31
          </sup>
          - 1)
         </p>
        </td>
       </tr>
       <tr id="-lztin5_18">
        <td id="-lztin5_40">
         <p>
          <code class="code" id="-lztin5_44">
           Long
          </code>
         </p>
        </td>
        <td id="-lztin5_41">
         <p>
          64
         </p>
        </td>
        <td id="-lztin5_42">
         <p>
          -9,223,372,036,854,775,808 (-2
          <sup class="superscript" id="-lztin5_45">
           63
          </sup>
          )
         </p>
        </td>
        <td id="-lztin5_43">
         <p>
          9,223,372,036,854,775,807 (2
          <sup class="superscript" id="-lztin5_46">
           63
          </sup>
          - 1)
         </p>
        </td>
       </tr>
      </tbody>
     </table>
    </div>
    <p id="-lztin5_10">
     When you initialize a variable with no explicit type specification, the compiler automatically infers the type with the smallest range enough to represent the value starting from
     <code class="code" id="-lztin5_47">
      Int
     </code>
     . If it is not exceeding the range of
     <code class="code" id="-lztin5_48">
      Int
     </code>
     , the type is
     <code class="code" id="-lztin5_49">
      Int
     </code>
     . If it exceeds, the type is
     <code class="code" id="-lztin5_50">
      Long
     </code>
     . To specify the
     <code class="code" id="-lztin5_51">
      Long
     </code>
     value explicitly, append the suffix
     <code class="code" id="-lztin5_52">
      L
     </code>
     to the value. Explicit type specification triggers the compiler to check the value not to exceed the range of the specified type.
    </p>
    <div class="code-block" data-lang="kotlin">
     val one = 1 // Int
val threeBillion = 3000000000 // Long
val oneLong = 1L // Long
val oneByte: Byte = 1
    </div>
    <aside class="prompt" data-title="" data-type="tip" id="-lztin5_12">
     <p id="-lztin5_53">
      In addition to integer types, Kotlin also provides unsigned integer types. For more information, see
      <a data-tooltip="In addition to integer types, Kotlin provides the following types for unsigned integer numbers:" href="unsigned-integer-types.html" id="-lztin5_54">
       Unsigned integer types
      </a>
      .
     </p>
    </aside>
   </section>
   <section class="chapter">
    <h2 data-toc="floating-point-types" id="floating-point-types">
     Floating-point types
    </h2>
    <p id="-lztin5_55">
     For real numbers, Kotlin provides floating-point types
     <code class="code" id="-lztin5_65">
      Float
     </code>
     and
     <code class="code" id="-lztin5_66">
      Double
     </code>
     that adhere to the
     <a data-external="true" href="https://en.wikipedia.org/wiki/IEEE_754" id="-lztin5_67" rel="noopener noreferrer">
      IEEE 754 standard
     </a>
     .
     <code class="code" id="-lztin5_68">
      Float
     </code>
     reflects the IEEE 754
     <span class="emphasis" id="-lztin5_69">
      single precision
     </span>
     , while
     <code class="code" id="-lztin5_70">
      Double
     </code>
     reflects
     <span class="emphasis" id="-lztin5_71">
      double precision
     </span>
     .
    </p>
    <p id="-lztin5_56">
     These types differ in their size and provide storage for floating-point numbers with different precision:
    </p>
    <div class="table-wrapper">
     <table class="wide" id="-lztin5_57">
      <thead>
       <tr class="ijRowHead" id="-lztin5_72">
        <th id="-lztin5_75">
         <p>
          Type
         </p>
        </th>
        <th id="-lztin5_76">
         <p>
          Size (bits)
         </p>
        </th>
        <th id="-lztin5_77">
         <p>
          Significant bits
         </p>
        </th>
        <th id="-lztin5_78">
         <p>
          Exponent bits
         </p>
        </th>
        <th id="-lztin5_79">
         <p>
          Decimal digits
         </p>
        </th>
       </tr>
      </thead>
      <tbody>
       <tr id="-lztin5_73">
        <td id="-lztin5_80">
         <p>
          <code class="code" id="-lztin5_85">
           Float
          </code>
         </p>
        </td>
        <td id="-lztin5_81">
         <p>
          32
         </p>
        </td>
        <td id="-lztin5_82">
         <p>
          24
         </p>
        </td>
        <td id="-lztin5_83">
         <p>
          8
         </p>
        </td>
        <td id="-lztin5_84">
         <p>
          6-7
         </p>
        </td>
       </tr>
       <tr id="-lztin5_74">
        <td id="-lztin5_86">
         <p>
          <code class="code" id="-lztin5_91">
           Double
          </code>
         </p>
        </td>
        <td id="-lztin5_87">
         <p>
          64
         </p>
        </td>
        <td id="-lztin5_88">
         <p>
          53
         </p>
        </td>
        <td id="-lztin5_89">
         <p>
          11
         </p>
        </td>
        <td id="-lztin5_90">
         <p>
          15-16
         </p>
        </td>
       </tr>
      </tbody>
     </table>
    </div>
    <p id="-lztin5_58">
     You can initialize
     <code class="code" id="-lztin5_92">
      Double
     </code>
     and
     <code class="code" id="-lztin5_93">
      Float
     </code>
     variables with numbers having a fractional part. It's separated from the integer part by a period (
     <code class="code" id="-lztin5_94">
      .
     </code>
     ) For variables initialized with fractional numbers, the compiler infers the
     <code class="code" id="-lztin5_95">
      Double
     </code>
     type:
    </p>
    <div class="code-block" data-lang="kotlin">
     val pi = 3.14 // Double
// val one: Double = 1 // Error: type mismatch
val oneDouble = 1.0 // Double
    </div>
    <p id="-lztin5_60">
     To explicitly specify the
     <code class="code" id="-lztin5_96">
      Float
     </code>
     type for a value, add the suffix
     <code class="code" id="-lztin5_97">
      f
     </code>
     or
     <code class="code" id="-lztin5_98">
      F
     </code>
     . If such a value contains more than 6-7 decimal digits, it will be rounded:
    </p>
    <div class="code-block" data-lang="kotlin">
     val e = 2.7182818284 // Double
val eFloat = 2.7182818284f // Float, actual value is 2.7182817
    </div>
    <p id="-lztin5_62">
     Unlike some other languages, there are no implicit widening conversions for numbers in Kotlin. For example, a function with a
     <code class="code" id="-lztin5_99">
      Double
     </code>
     parameter can be called only on
     <code class="code" id="-lztin5_100">
      Double
     </code>
     values, but not
     <code class="code" id="-lztin5_101">
      Float
     </code>
     ,
     <code class="code" id="-lztin5_102">
      Int
     </code>
     , or other numeric values:
    </p>
    <div class="code-block" data-lang="kotlin">
     fun main() {
    fun printDouble(d: Double) { print(d) }

    val i = 1    
    val d = 1.0
    val f = 1.0f 

    printDouble(d)
//    printDouble(i) // Error: Type mismatch
//    printDouble(f) // Error: Type mismatch
}
    </div>
    <p id="-lztin5_64">
     To convert numeric values to different types, use
     <a data-tooltip="Due to different representations, smaller types are not subtypes of bigger ones. If they were, we would have troubles of the following sort:" href="#explicit-number-conversions" id="-lztin5_103">
      explicit conversions
     </a>
     .
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="literal-constants-for-numbers" id="literal-constants-for-numbers">
     Literal constants for numbers
    </h2>
    <p id="-lztin5_104">
     There are the following kinds of literal constants for integral values:
    </p>
    <ul class="list _bullet" id="-lztin5_105">
     <li class="list__item" id="-lztin5_112">
      <p>
       Decimals:
       <code class="code" id="-lztin5_116">
        123
       </code>
      </p>
     </li>
     <li class="list__item" id="-lztin5_113">
      <p>
       Longs are tagged by a capital
       <code class="code" id="-lztin5_117">
        L
       </code>
       :
       <code class="code" id="-lztin5_118">
        123L
       </code>
      </p>
     </li>
     <li class="list__item" id="-lztin5_114">
      <p>
       Hexadecimals:
       <code class="code" id="-lztin5_119">
        0x0F
       </code>
      </p>
     </li>
     <li class="list__item" id="-lztin5_115">
      <p>
       Binaries:
       <code class="code" id="-lztin5_120">
        0b00001011
       </code>
      </p>
     </li>
    </ul>
    <aside class="prompt" data-title="" data-type="note" id="-lztin5_106">
     <p id="-lztin5_121">
      Octal literals are not supported in Kotlin.
     </p>
    </aside>
    <p id="-lztin5_107">
     Kotlin also supports a conventional notation for floating-point numbers:
    </p>
    <ul class="list _bullet" id="-lztin5_108">
     <li class="list__item" id="-lztin5_122">
      <p>
       Doubles by default:
       <code class="code" id="-lztin5_124">
        123.5
       </code>
       ,
       <code class="code" id="-lztin5_125">
        123.5e10
       </code>
      </p>
     </li>
     <li class="list__item" id="-lztin5_123">
      <p>
       Floats are tagged by
       <code class="code" id="-lztin5_126">
        f
       </code>
       or
       <code class="code" id="-lztin5_127">
        F
       </code>
       :
       <code class="code" id="-lztin5_128">
        123.5f
       </code>
      </p>
     </li>
    </ul>
    <p id="-lztin5_109">
     You can use underscores to make number constants more readable:
    </p>
    <div class="code-block" data-lang="kotlin">
     val oneMillion = 1_000_000
val creditCardNumber = 1234_5678_9012_3456L
val socialSecurityNumber = 999_99_9999L
val hexBytes = 0xFF_EC_DE_5E
val bytes = 0b11010010_01101001_10010100_10010010
    </div>
    <aside class="prompt" data-title="" data-type="tip" id="-lztin5_111">
     <p id="-lztin5_129">
      There are also special tags for unsigned integer literals.
      <br/>
      Read more about
      <a data-tooltip="In addition to integer types, Kotlin provides the following types for unsigned integer numbers:" href="unsigned-integer-types.html" id="-lztin5_131">
       literals for unsigned integer types
      </a>
      .
     </p>
    </aside>
   </section>
   <section class="chapter">
    <h2 data-toc="numbers-representation-on-the-jvm" id="numbers-representation-on-the-jvm">
     Numbers representation on the JVM
    </h2>
    <p id="-lztin5_132">
     On the JVM platform, numbers are stored as primitive types:
     <code class="code" id="-lztin5_138">
      int
     </code>
     ,
     <code class="code" id="-lztin5_139">
      double
     </code>
     , and so on. Exceptions are cases when you create a nullable number reference such as
     <code class="code" id="-lztin5_140">
      Int?
     </code>
     or use generics. In these cases numbers are boxed in Java classes
     <code class="code" id="-lztin5_141">
      Integer
     </code>
     ,
     <code class="code" id="-lztin5_142">
      Double
     </code>
     , and so on.
    </p>
    <p id="-lztin5_133">
     Nullable references to the same number can refer to different objects:
    </p>
    <div class="code-block" data-lang="kotlin" data-min-compiler-version="1.3" data-runnable="true">
     fun main() {
//sampleStart
    val a: Int = 100
    val boxedA: Int? = a
    val anotherBoxedA: Int? = a
    
    val b: Int = 10000
    val boxedB: Int? = b
    val anotherBoxedB: Int? = b
    
    println(boxedA === anotherBoxedA) // true
    println(boxedB === anotherBoxedB) // false
//sampleEnd
}
    </div>
    <p id="-lztin5_135">
     All nullable references to
     <code class="code" id="-lztin5_143">
      a
     </code>
     are actually the same object because of the memory optimization that JVM applies to
     <code class="code" id="-lztin5_144">
      Integer
     </code>
     s between
     <code class="code" id="-lztin5_145">
      -128
     </code>
     and
     <code class="code" id="-lztin5_146">
      127
     </code>
     . It doesn't apply to the
     <code class="code" id="-lztin5_147">
      b
     </code>
     references, so they are different objects.
    </p>
    <p id="-lztin5_136">
     On the other hand, they are still equal:
    </p>
    <div class="code-block" data-lang="kotlin" data-min-compiler-version="1.3" data-runnable="true">
     fun main() {
//sampleStart
    val b: Int = 10000
    println(b == b) // Prints 'true'
    val boxedB: Int? = b
    val anotherBoxedB: Int? = b
    println(boxedB == anotherBoxedB) // Prints 'true'
//sampleEnd
}
    </div>
   </section>
   <section class="chapter">
    <h2 data-toc="explicit-number-conversions" id="explicit-number-conversions">
     Explicit number conversions
    </h2>
    <p id="-lztin5_148">
     Due to different representations, smaller types
     <span class="emphasis" id="-lztin5_157">
      are not subtypes
     </span>
     of bigger ones. If they were, we would have troubles of the following sort:
    </p>
    <div class="code-block" data-lang="kotlin">
     // Hypothetical code, does not actually compile:
val a: Int? = 1 // A boxed Int (java.lang.Integer)
val b: Long? = a // Implicit conversion yields a boxed Long (java.lang.Long)
print(b == a) // Surprise! This prints "false" as Long's equals() checks whether the other is Long as well
    </div>
    <p id="-lztin5_150">
     So equality would have been lost silently, not to mention identity.
    </p>
    <p id="-lztin5_151">
     As a consequence, smaller types
     <span class="emphasis" id="-lztin5_158">
      are NOT implicitly converted
     </span>
     to bigger types. This means that assigning a value of type
     <code class="code" id="-lztin5_159">
      Byte
     </code>
     to an
     <code class="code" id="-lztin5_160">
      Int
     </code>
     variable requires an explicit conversion:
    </p>
    <div class="code-block" data-lang="kotlin">
     val b: Byte = 1 // OK, literals are checked statically
// val i: Int = b // ERROR
val i1: Int = b.toInt()
    </div>
    <p id="-lztin5_153">
     All number types support conversions to other types:
    </p>
    <ul class="list _bullet" id="-lztin5_154">
     <li class="list__item" id="-lztin5_161">
      <p>
       <code class="code" id="-lztin5_167">
        toByte(): Byte
       </code>
      </p>
     </li>
     <li class="list__item" id="-lztin5_162">
      <p>
       <code class="code" id="-lztin5_168">
        toShort(): Short
       </code>
      </p>
     </li>
     <li class="list__item" id="-lztin5_163">
      <p>
       <code class="code" id="-lztin5_169">
        toInt(): Int
       </code>
      </p>
     </li>
     <li class="list__item" id="-lztin5_164">
      <p>
       <code class="code" id="-lztin5_170">
        toLong(): Long
       </code>
      </p>
     </li>
     <li class="list__item" id="-lztin5_165">
      <p>
       <code class="code" id="-lztin5_171">
        toFloat(): Float
       </code>
      </p>
     </li>
     <li class="list__item" id="-lztin5_166">
      <p>
       <code class="code" id="-lztin5_172">
        toDouble(): Double
       </code>
      </p>
     </li>
    </ul>
    <p id="-lztin5_155">
     In many cases, there is no need for explicit conversions because the type is inferred from the context, and arithmetical operations are overloaded for appropriate conversions, for example:
    </p>
    <div class="code-block" data-lang="kotlin">
     val l = 1L + 3 // Long + Int =&gt; Long
    </div>
   </section>
   <section class="chapter">
    <h2 data-toc="operations-on-numbers" id="operations-on-numbers">
     Operations on numbers
    </h2>
    <p id="-lztin5_173">
     Kotlin supports the standard set of arithmetical operations over numbers:
     <code class="code" id="-lztin5_179">
      +
     </code>
     ,
     <code class="code" id="-lztin5_180">
      -
     </code>
     ,
     <code class="code" id="-lztin5_181">
      *
     </code>
     ,
     <code class="code" id="-lztin5_182">
      /
     </code>
     ,
     <code class="code" id="-lztin5_183">
      %
     </code>
     . They are declared as members of appropriate classes:
    </p>
    <div class="code-block" data-lang="kotlin" data-min-compiler-version="1.3" data-runnable="true">
     fun main() {
//sampleStart
    println(1 + 2)
    println(2_500_000_000L - 1L)
    println(3.14 * 2.71)
    println(10.0 / 3)
//sampleEnd
}
    </div>
    <p id="-lztin5_175">
     You can also override these operators for custom classes. See
     <a data-tooltip="Kotlin allows you to provide custom implementations for the predefined set of operators on types. These operators have predefined symbolic representation (like + or *) and precedence. To implement an operator, provide a member function or an extension function with a specific name…" href="operator-overloading.html" id="-lztin5_184">
      Operator overloading
     </a>
     for details.
    </p>
    <section class="chapter">
     <h3 data-toc="division-of-integers" id="division-of-integers">
      Division of integers
     </h3>
     <p id="-lztin5_185">
      Division between integers numbers always returns an integer number. Any fractional part is discarded.
     </p>
     <div class="code-block" data-lang="kotlin" data-min-compiler-version="1.3" data-runnable="true">
      fun main() {
//sampleStart
    val x = 5 / 2
    //println(x == 2.5) // ERROR: Operator '==' cannot be applied to 'Int' and 'Double'
    println(x == 2)
//sampleEnd
}
     </div>
     <p id="-lztin5_187">
      This is true for a division between any two integer types:
     </p>
     <div class="code-block" data-lang="kotlin" data-min-compiler-version="1.3" data-runnable="true">
      fun main() {
//sampleStart
    val x = 5L / 2
    println(x == 2L)
//sampleEnd
}
     </div>
     <p id="-lztin5_189">
      To return a floating-point type, explicitly convert one of the arguments to a floating-point type:
     </p>
     <div class="code-block" data-lang="kotlin" data-min-compiler-version="1.3" data-runnable="true">
      fun main() {
//sampleStart
    val x = 5 / 2.toDouble()
    println(x == 2.5)
//sampleEnd
}
     </div>
    </section>
    <section class="chapter">
     <h3 data-toc="bitwise-operations" id="bitwise-operations">
      Bitwise operations
     </h3>
     <p id="-lztin5_191">
      Kotlin provides a set of
      <span class="emphasis" id="-lztin5_195">
       bitwise operations
      </span>
      on integer numbers. They operate on the binary level directly with bits of the numbers' representation. Bitwise operations are represented by functions that can be called in infix form. They can be applied only to
      <code class="code" id="-lztin5_196">
       Int
      </code>
      and
      <code class="code" id="-lztin5_197">
       Long
      </code>
      :
     </p>
     <div class="code-block" data-lang="kotlin">
      val x = (1 shl 2) and 0x000FF000
     </div>
     <p id="-lztin5_193">
      Here is the complete list of bitwise operations:
     </p>
     <ul class="list _bullet" id="-lztin5_194">
      <li class="list__item" id="-lztin5_198">
       <p>
        <code class="code" id="-lztin5_205">
         shl(bits)
        </code>
        – signed shift left
       </p>
      </li>
      <li class="list__item" id="-lztin5_199">
       <p>
        <code class="code" id="-lztin5_206">
         shr(bits)
        </code>
        – signed shift right
       </p>
      </li>
      <li class="list__item" id="-lztin5_200">
       <p>
        <code class="code" id="-lztin5_207">
         ushr(bits)
        </code>
        – unsigned shift right
       </p>
      </li>
      <li class="list__item" id="-lztin5_201">
       <p>
        <code class="code" id="-lztin5_208">
         and(bits)
        </code>
        – bitwise
        <span class="control" id="-lztin5_209">
         AND
        </span>
       </p>
      </li>
      <li class="list__item" id="-lztin5_202">
       <p>
        <code class="code" id="-lztin5_210">
         or(bits)
        </code>
        – bitwise
        <span class="control" id="-lztin5_211">
         OR
        </span>
       </p>
      </li>
      <li class="list__item" id="-lztin5_203">
       <p>
        <code class="code" id="-lztin5_212">
         xor(bits)
        </code>
        – bitwise
        <span class="control" id="-lztin5_213">
         XOR
        </span>
       </p>
      </li>
      <li class="list__item" id="-lztin5_204">
       <p>
        <code class="code" id="-lztin5_214">
         inv()
        </code>
        – bitwise inversion
       </p>
      </li>
     </ul>
    </section>
    <section class="chapter">
     <h3 data-toc="floating-point-numbers-comparison" id="floating-point-numbers-comparison">
      Floating-point numbers comparison
     </h3>
     <p id="-lztin5_215">
      The operations on floating-point numbers discussed in this section are:
     </p>
     <ul class="list _bullet" id="-lztin5_216">
      <li class="list__item" id="-lztin5_222">
       <p>
        Equality checks:
        <code class="code" id="-lztin5_225">
         a == b
        </code>
        and
        <code class="code" id="-lztin5_226">
         a != b
        </code>
       </p>
      </li>
      <li class="list__item" id="-lztin5_223">
       <p>
        Comparison operators:
        <code class="code" id="-lztin5_227">
         a &lt; b
        </code>
        ,
        <code class="code" id="-lztin5_228">
         a &gt; b
        </code>
        ,
        <code class="code" id="-lztin5_229">
         a &lt;= b
        </code>
        ,
        <code class="code" id="-lztin5_230">
         a &gt;= b
        </code>
       </p>
      </li>
      <li class="list__item" id="-lztin5_224">
       <p>
        Range instantiation and range checks:
        <code class="code" id="-lztin5_231">
         a..b
        </code>
        ,
        <code class="code" id="-lztin5_232">
         x in a..b
        </code>
        ,
        <code class="code" id="-lztin5_233">
         x !in a..b
        </code>
       </p>
      </li>
     </ul>
     <p id="-lztin5_217">
      When the operands
      <code class="code" id="-lztin5_234">
       a
      </code>
      and
      <code class="code" id="-lztin5_235">
       b
      </code>
      are statically known to be
      <code class="code" id="-lztin5_236">
       Float
      </code>
      or
      <code class="code" id="-lztin5_237">
       Double
      </code>
      or their nullable counterparts (the type is declared or inferred or is a result of a
      <a data-tooltip="In most cases, you don't need to use explicit cast operators because the compiler automatically casts objects for you. This is called smart-casting. The compiler tracks the type checks and explicit casts for immutable values and inserts implicit (safe) casts automatically when…" href="typecasts.html#smart-casts" id="-lztin5_238">
       smart cast
      </a>
      ), the operations on the numbers and the range that they form follow the
      <a data-external="true" href="https://en.wikipedia.org/wiki/IEEE_754" id="-lztin5_239" rel="noopener noreferrer">
       IEEE 754 Standard for Floating-Point Arithmetic
      </a>
      .
     </p>
     <p id="-lztin5_218">
      However, to support generic use cases and provide total ordering, the behavior is different for operands that are
      <span class="control" id="-lztin5_240">
       not
      </span>
      statically typed as floating-point numbers. For example,
      <code class="code" id="-lztin5_241">
       Any
      </code>
      ,
      <code class="code" id="-lztin5_242">
       Comparable&lt;...&gt;
      </code>
      , or
      <code class="code" id="-lztin5_243">
       Collection&lt;T&gt;
      </code>
      types. In this case, the operations use the
      <code class="code" id="-lztin5_244">
       equals
      </code>
      and
      <code class="code" id="-lztin5_245">
       compareTo
      </code>
      implementations for
      <code class="code" id="-lztin5_246">
       Float
      </code>
      and
      <code class="code" id="-lztin5_247">
       Double
      </code>
      . As a result:
     </p>
     <ul class="list _bullet" id="-lztin5_219">
      <li class="list__item" id="-lztin5_248">
       <p>
        <code class="code" id="-lztin5_251">
         NaN
        </code>
        is considered equal to itself
       </p>
      </li>
      <li class="list__item" id="-lztin5_249">
       <p>
        <code class="code" id="-lztin5_252">
         NaN
        </code>
        is considered greater than any other element including
        <code class="code" id="-lztin5_253">
         POSITIVE_INFINITY
        </code>
       </p>
      </li>
      <li class="list__item" id="-lztin5_250">
       <p>
        <code class="code" id="-lztin5_254">
         -0.0
        </code>
        is considered less than
        <code class="code" id="-lztin5_255">
         0.0
        </code>
       </p>
      </li>
     </ul>
     <p id="-lztin5_220">
      Here is an example that shows the difference in behavior between operands statically typed as floating-point numbers (
      <code class="code" id="-lztin5_256">
       Double.NaN
      </code>
      ) and operands
      <span class="control" id="-lztin5_257">
       not
      </span>
      statically typed as floating-point numbers (
      <code class="code" id="-lztin5_258">
       listOf(T)
      </code>
      ).
     </p>
     <div class="code-block" data-lang="kotlin" data-min-compiler-version="1.3" data-runnable="true" id="kotlin-numbers-floating-comp">
      fun main() {
    //sampleStart
    // Operand statically typed as floating-point number
    println(Double.NaN == Double.NaN)                 // false
    // Operand NOT statically typed as floating-point number
    // So NaN is equal to itself
    println(listOf(Double.NaN) == listOf(Double.NaN)) // true

    // Operand statically typed as floating-point number
    println(0.0 == -0.0)                              // true
    // Operand NOT statically typed as floating-point number
    // So -0.0 is less than 0.0
    println(listOf(0.0) == listOf(-0.0))              // false

    println(listOf(Double.NaN, Double.POSITIVE_INFINITY, 0.0, -0.0).sorted())
    // [-0.0, 0.0, Infinity, NaN]
    //sampleEnd
}
     </div>
    </section>
   </section>
   <div class="last-modified">
    Last modified: 16 December 2024
   </div>
   <div data-feedback-placeholder="true">
   </div>
  </div>
 </body>
</html>
