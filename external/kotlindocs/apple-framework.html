<html>
 <head>
  <meta charset="utf-8"/>
  <link href="doc_style.css" rel="stylesheet"/>
 </head>
 <body>
  <a class="menu-link" href="toc.html">
   MENU
  </a>
  <hr/>
  <div class="article-content">
   <h1 data-toc="apple-framework" id="apple-framework.md">
    Kotlin/Native as an Apple framework – tutorial
   </h1>
   <aside class="prompt" data-title="" data-type="warning" id="y98mgu_2">
    <p id="y98mgu_16">
     The Objective-C libraries import is
     <a data-tooltip="Here's a quick guide to these stability levels and their meaning:" href="components-stability.html#stability-levels-explained" id="y98mgu_18">
      Experimental
     </a>
     . All Kotlin declarations generated by the cinterop tool from Objective-C libraries should have the
     <code class="code" id="y98mgu_19">
      @ExperimentalForeignApi
     </code>
     annotation.
    </p>
    <p id="y98mgu_17">
     Native platform libraries shipped with Kotlin/Native (like Foundation, UIKit, and POSIX), require opt-in only for some APIs. In such cases, you get an IDE warning.
    </p>
   </aside>
   <p id="y98mgu_3">
    Kotlin/Native provides bidirectional interoperability with Swift/Objective-C. You can both use Objective-C frameworks and libraries in Kotlin code, and Kotlin modules in Swift/Objective-C code.
   </p>
   <p id="y98mgu_4">
    Kotlin/Native comes with a set of pre-imported system frameworks; it's also possible to import an existing framework and use it from Kotlin. In this tutorial, you'll learn how to create your own framework and use Kotlin/Native code from Swift/Objective-C applications on macOS and iOS.
   </p>
   <p id="y98mgu_5">
    In this tutorial, you will:
   </p>
   <ul class="list _bullet" id="y98mgu_6">
    <li class="list__item" id="y98mgu_20">
     <p>
      <a data-tooltip="See the Get started with Kotlin/Native tutorial for detailed first steps and instructions on how to create a new Kotlin/Native project and open it in IntelliJ IDEA." href="#create-a-kotlin-library" id="y98mgu_24">
       Create a Kotlin library and compile it to a framework
      </a>
     </p>
    </li>
    <li class="list__item" id="y98mgu_21">
     <p>
      <a data-tooltip="Each framework variant contains a header file. The headers don't depend on the target platform. Header files contain definitions for your Kotlin code and a few Kotlin-wide declarations. Let's see what's inside." href="#generated-framework-headers" id="y98mgu_25">
       Examine the generated Swift/Objective-C API code
      </a>
     </p>
    </li>
    <li class="list__item" id="y98mgu_22">
     <p>
      <a data-tooltip="Let's call the framework from Objective-C. In the framework directory, create the main.m file with the following code:" href="#use-code-from-objective-c" id="y98mgu_26">
       Use the framework from Objective-C
      </a>
     </p>
    </li>
    <li class="list__item" id="y98mgu_23">
     <p>
      <a data-tooltip="The framework you generated has helper attributes to make it easier to use with Swift. Let's convert the previous Objective-C example into Swift." href="#use-code-from-swift" id="y98mgu_27">
       Use the framework from Swift
      </a>
     </p>
    </li>
   </ul>
   <p id="y98mgu_7">
    You can use the command line to generate a Kotlin framework, either directly or with a script file (such as
    <code class="code" id="y98mgu_28">
     .sh
    </code>
    or
    <code class="code" id="y98mgu_29">
     .bat
    </code>
    file). However, this approach doesn't scale well for big projects that have hundreds of files and libraries. Using a build system simplifies the process by downloading and caching the Kotlin/Native compiler binaries and libraries with transitive dependencies and run the compiler and tests. Kotlin/Native can use the
    <a data-external="true" href="https://gradle.org" id="y98mgu_30" rel="noopener noreferrer">
     Gradle
    </a>
    build system through the
    <a data-tooltip="Projects targeting multiple platforms, called multiplatform projects, require the kotlin-multiplatform plugin." href="gradle-configure-project.html#targeting-multiple-platforms" id="y98mgu_31">
     Kotlin Multiplatform plugin
    </a>
    .
   </p>
   <aside class="prompt" data-title="" data-type="note" id="y98mgu_8">
    <p id="y98mgu_32">
     If you use a Mac and want to create and run applications for iOS or other Apple targets, you also need to install the
     <a data-external="true" href="https://developer.apple.com/download/" id="y98mgu_33" rel="noopener noreferrer">
      Xcode Command Line Tools
     </a>
     , launch it, and accept the license terms first.
    </p>
   </aside>
   <section class="chapter">
    <h2 data-toc="create-a-kotlin-library" id="create-a-kotlin-library">
     Create a Kotlin library
    </h2>
    <aside class="prompt" data-title="" data-type="tip" id="y98mgu_34">
     <p id="y98mgu_40">
      See the
      <a data-tooltip="In this section, you'll learn how to manually create a Kotlin/Native application using Gradle. It's the default build system for Kotlin/Native and Kotlin Multiplatform projects, which is also commonly used in Java, Android, and other ecosystems." href="native-get-started.html#using-gradle" id="y98mgu_41">
       Get started with Kotlin/Native
      </a>
      tutorial for detailed first steps and instructions on how to create a new Kotlin/Native project and open it in IntelliJ IDEA.
     </p>
    </aside>
    <p id="y98mgu_35">
     The Kotlin/Native compiler can produce a framework for macOS and iOS from the Kotlin code. The created framework contains all declarations and binaries needed to use it with Swift/Objective-C.
    </p>
    <p id="y98mgu_36">
     Let's first create a Kotlin library:
    </p>
    <ol class="list _decimal" id="y98mgu_37" type="1">
     <li class="list__item" id="y98mgu_42">
      <p id="y98mgu_45">
       In the
       <code class="code" id="y98mgu_47">
        src/nativeMain/kotlin
       </code>
       directory, create the
       <code class="code" id="y98mgu_48">
        lib.kt
       </code>
       file with the library contents:
      </p>
      <div class="code-block" data-lang="kotlin">
       package example

object Object {
    val field = "A"
}

interface Interface {
    fun iMember() {}
}

class Clazz : Interface {
    fun member(p: Int): ULong? = 42UL
}

fun forIntegers(b: Byte, s: UShort, i: Int, l: ULong?) { }
fun forFloats(f: Float, d: Double?) { }

fun strings(str: String?) : String {
    return "That is '$str' from C"
}

fun acceptFun(f: (String) -&gt; String?) = f("Kotlin/Native rocks!")
fun supplyFun() : (String) -&gt; String? = { "$it is cool!" }
      </div>
     </li>
     <li class="list__item" id="y98mgu_43">
      <p id="y98mgu_49">
       Update your
       <code class="code" id="y98mgu_55">
        build.gradle(.kts)
       </code>
       Gradle build file with the following:
      </p>
      <div class="tabs" data-anchors="[y98mgu_56,y98mgu_57]" data-group="build-script" id="y98mgu_50">
       <div class="tabs__content" data-gtm="tab" data-sync-tabs="kotlin" data-title="Kotlin" id="y98mgu_56">
        <div class="code-block" data-lang="kotlin" data-title="Kotlin">
         plugins {
    kotlin("multiplatform") version "2.1.0"
}

repositories {
    mavenCentral()
}

kotlin {
    iosArm64("native") {
        binaries {
            framework {
                baseName = "Demo"
            }
        }
    }
}

tasks.wrapper {
    gradleVersion = "8.10"
    distributionType = Wrapper.DistributionType.ALL
}
        </div>
       </div>
       <div class="tabs__content" data-gtm="tab" data-sync-tabs="groovy" data-title="Groovy" id="y98mgu_57">
        <div class="code-block" data-lang="groovy" data-title="Groovy">
         plugins {
    id 'org.jetbrains.kotlin.multiplatform' version '2.1.0'
}

repositories {
    mavenCentral()
}

kotlin {
    iosArm64("native") {
        binaries {
            framework {
                baseName = "Demo"
            }
        }
    }
}

wrapper {
    gradleVersion = "8.10"
    distributionType = "ALL"
}
        </div>
       </div>
      </div>
      <p id="y98mgu_51">
       The
       <code class="code" id="y98mgu_60">
        binaries {}
       </code>
       block configures the project to generate a dynamic or shared library.
      </p>
      <p id="y98mgu_52">
       Kotlin/Native supports the
       <code class="code" id="y98mgu_61">
        iosArm64
       </code>
       ,
       <code class="code" id="y98mgu_62">
        iosX64
       </code>
       , and
       <code class="code" id="y98mgu_63">
        iosSimulatorArm64
       </code>
       targets for iOS, as well as
       <code class="code" id="y98mgu_64">
        macosX64
       </code>
       and
       <code class="code" id="y98mgu_65">
        macosArm64
       </code>
       targets for macOS. So, you can replace the
       <code class="code" id="y98mgu_66">
        iosArm64()
       </code>
       with the respective Gradle function for your target platform:
      </p>
      <div class="table-wrapper">
       <table class="wide" id="y98mgu_53">
        <thead>
         <tr class="ijRowHead" id="y98mgu_67">
          <th id="y98mgu_73">
           <p>
            Target platform/device
           </p>
          </th>
          <th id="y98mgu_74">
           <p>
            Gradle function
           </p>
          </th>
         </tr>
        </thead>
        <tbody>
         <tr id="y98mgu_68">
          <td id="y98mgu_75">
           <p>
            macOS x86_64
           </p>
          </td>
          <td id="y98mgu_76">
           <p>
            <code class="code" id="y98mgu_77">
             macosX64()
            </code>
           </p>
          </td>
         </tr>
         <tr id="y98mgu_69">
          <td id="y98mgu_78">
           <p>
            macOS ARM64
           </p>
          </td>
          <td id="y98mgu_79">
           <p>
            <code class="code" id="y98mgu_80">
             macosArm64()
            </code>
           </p>
          </td>
         </tr>
         <tr id="y98mgu_70">
          <td id="y98mgu_81">
           <p>
            iOS ARM64
           </p>
          </td>
          <td id="y98mgu_82">
           <p>
            <code class="code" id="y98mgu_83">
             iosArm64()
            </code>
           </p>
          </td>
         </tr>
         <tr id="y98mgu_71">
          <td id="y98mgu_84">
           <p>
            iOS Simulator (x86_64)
           </p>
          </td>
          <td id="y98mgu_85">
           <p>
            <code class="code" id="y98mgu_86">
             iosX64()
            </code>
           </p>
          </td>
         </tr>
         <tr id="y98mgu_72">
          <td id="y98mgu_87">
           <p>
            iOS Simulator (ARM64)
           </p>
          </td>
          <td id="y98mgu_88">
           <p>
            <code class="code" id="y98mgu_89">
             iosSimulatorArm64()
            </code>
           </p>
          </td>
         </tr>
        </tbody>
       </table>
      </div>
      <p id="y98mgu_54">
       For information on other supported Apple targets, see
       <a data-tooltip="The Kotlin/Native compiler supports a great number of different targets, though it is hard to provide the same level of support for all of them. This document describes which targets Kotlin/Native supports and breaks them into several tiers depending on how well the compiler…" href="native-target-support.html" id="y98mgu_90">
        Kotlin/Native target support
       </a>
       .
      </p>
     </li>
     <li class="list__item" id="y98mgu_44">
      <p id="y98mgu_91">
       Run the
       <code class="code" id="y98mgu_93">
        linkDebugFrameworkNative
       </code>
       Gradle task in the IDE or use the following console command in your terminal to build the framework:
      </p>
      <div class="code-block" data-lang="bash">
       ./gradlew linkDebugFrameworkNative
      </div>
     </li>
    </ol>
    <p id="y98mgu_38">
     The build generates the framework into the
     <code class="code" id="y98mgu_94">
      build/bin/native/debugFramework
     </code>
     directory.
    </p>
    <aside class="prompt" data-title="" data-type="tip" id="y98mgu_39">
     <p id="y98mgu_95">
      You can also use the
      <code class="code" id="y98mgu_96">
       linkNative
      </code>
      Gradle task to generate both
      <code class="code" id="y98mgu_97">
       debug
      </code>
      and
      <code class="code" id="y98mgu_98">
       release
      </code>
      variants of the framework.
     </p>
    </aside>
   </section>
   <section class="chapter">
    <h2 data-toc="generated-framework-headers" id="generated-framework-headers">
     Generated framework headers
    </h2>
    <p id="y98mgu_99">
     Each framework variant contains a header file. The headers don't depend on the target platform. Header files contain definitions for your Kotlin code and a few Kotlin-wide declarations. Let's see what's inside.
    </p>
    <section class="chapter">
     <h3 data-toc="kotlin-native-runtime-declarations" id="kotlin-native-runtime-declarations">
      Kotlin/Native runtime declarations
     </h3>
     <p id="y98mgu_104">
      In the
      <code class="code" id="y98mgu_108">
       build/bin/native/debugFramework/Demo.framework/Headers
      </code>
      directory, open the
      <code class="code" id="y98mgu_109">
       Demo.h
      </code>
      header file. Take a look at Kotlin runtime declarations:
     </p>
     <div class="code-block" data-lang="objectivec">
      NS_ASSUME_NONNULL_BEGIN
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunknown-warning-option"
#pragma clang diagnostic ignored "-Wincompatible-property-type"
#pragma clang diagnostic ignored "-Wnullability"

#pragma push_macro("_Nullable_result")
#if !__has_feature(nullability_nullable_result)
#undef _Nullable_result
#define _Nullable_result _Nullable
#endif

__attribute__((swift_name("KotlinBase")))
@interface DemoBase : NSObject
- (instancetype)init __attribute__((unavailable));
+ (instancetype)new __attribute__((unavailable));
+ (void)initialize __attribute__((objc_requires_super));
@end

@interface DemoBase (DemoBaseCopying) &lt;NSCopying&gt;
@end

__attribute__((swift_name("KotlinMutableSet")))
@interface DemoMutableSet&lt;ObjectType&gt; : NSMutableSet&lt;ObjectType&gt;
@end

__attribute__((swift_name("KotlinMutableDictionary")))
@interface DemoMutableDictionary&lt;KeyType, ObjectType&gt; : NSMutableDictionary&lt;KeyType, ObjectType&gt;
@end

@interface NSError (NSErrorDemoKotlinException)
@property (readonly) id _Nullable kotlinException;
@end
     </div>
     <p id="y98mgu_106">
      Kotlin classes have a
      <code class="code" id="y98mgu_110">
       KotlinBase
      </code>
      base class in Swift/Objective-C that extends the
      <code class="code" id="y98mgu_111">
       NSObject
      </code>
      class there. There are also wrappers for collections and exceptions. Most of the collection types are mapped to similar collection types in Swift/Objective-C:
     </p>
     <div class="table-wrapper">
      <table class="wide" id="y98mgu_107">
       <thead>
        <tr class="ijRowHead" id="y98mgu_112">
         <th id="y98mgu_119">
          <p>
           Kotlin
          </p>
         </th>
         <th id="y98mgu_120">
          <p>
           Swift
          </p>
         </th>
         <th id="y98mgu_121">
          <p>
           Objective-C
          </p>
         </th>
        </tr>
       </thead>
       <tbody>
        <tr id="y98mgu_113">
         <td id="y98mgu_122">
          <p>
           List
          </p>
         </td>
         <td id="y98mgu_123">
          <p>
           Array
          </p>
         </td>
         <td id="y98mgu_124">
          <p>
           NSArray
          </p>
         </td>
        </tr>
        <tr id="y98mgu_114">
         <td id="y98mgu_125">
          <p>
           MutableList
          </p>
         </td>
         <td id="y98mgu_126">
          <p>
           NSMutableArray
          </p>
         </td>
         <td id="y98mgu_127">
          <p>
           NSMutableArray
          </p>
         </td>
        </tr>
        <tr id="y98mgu_115">
         <td id="y98mgu_128">
          <p>
           Set
          </p>
         </td>
         <td id="y98mgu_129">
          <p>
           Set
          </p>
         </td>
         <td id="y98mgu_130">
          <p>
           NSSet
          </p>
         </td>
        </tr>
        <tr id="y98mgu_116">
         <td id="y98mgu_131">
          <p>
           MutableSet
          </p>
         </td>
         <td id="y98mgu_132">
          <p>
           NSMutableSet
          </p>
         </td>
         <td id="y98mgu_133">
          <p>
           NSMutableSet
          </p>
         </td>
        </tr>
        <tr id="y98mgu_117">
         <td id="y98mgu_134">
          <p>
           Map
          </p>
         </td>
         <td id="y98mgu_135">
          <p>
           Dictionary
          </p>
         </td>
         <td id="y98mgu_136">
          <p>
           NSDictionary
          </p>
         </td>
        </tr>
        <tr id="y98mgu_118">
         <td id="y98mgu_137">
          <p>
           MutableMap
          </p>
         </td>
         <td id="y98mgu_138">
          <p>
           NSMutableDictionary
          </p>
         </td>
         <td id="y98mgu_139">
          <p>
           NSMutableDictionary
          </p>
         </td>
        </tr>
       </tbody>
      </table>
     </div>
    </section>
    <section class="chapter">
     <h3 data-toc="kotlin-numbers-and-nsnumber" id="kotlin-numbers-and-nsnumber">
      Kotlin numbers and NSNumber
     </h3>
     <p id="y98mgu_140">
      The next part of the
      <code class="code" id="y98mgu_147">
       Demo.h
      </code>
      file contains type mappings between Kotlin/Native number types and
      <code class="code" id="y98mgu_148">
       NSNumber
      </code>
      . The base class is called
      <code class="code" id="y98mgu_149">
       DemoNumber
      </code>
      in Objective-C and
      <code class="code" id="y98mgu_150">
       KotlinNumber
      </code>
      in Swift. It extends
      <code class="code" id="y98mgu_151">
       NSNumber
      </code>
      .
     </p>
     <p id="y98mgu_141">
      For each Kotlin number type, there is a corresponding predefined child class:
     </p>
     <div class="table-wrapper">
      <table class="wide" id="y98mgu_142">
       <thead>
        <tr class="ijRowHead" id="y98mgu_152">
         <th id="y98mgu_165">
          <p>
           Kotlin
          </p>
         </th>
         <th id="y98mgu_166">
          <p>
           Swift
          </p>
         </th>
         <th id="y98mgu_167">
          <p>
           Objective-C
          </p>
         </th>
         <th id="y98mgu_168">
          <p>
           Simple type
          </p>
         </th>
        </tr>
       </thead>
       <tbody>
        <tr id="y98mgu_153">
         <td id="y98mgu_169">
          <p>
           <code class="code" id="y98mgu_173">
            -
           </code>
          </p>
         </td>
         <td id="y98mgu_170">
          <p>
           <code class="code" id="y98mgu_174">
            KotlinNumber
           </code>
          </p>
         </td>
         <td id="y98mgu_171">
          <p>
           <code class="code" id="y98mgu_175">
            &lt;Package&gt;Number
           </code>
          </p>
         </td>
         <td id="y98mgu_172">
          <p>
           <code class="code" id="y98mgu_176">
            -
           </code>
          </p>
         </td>
        </tr>
        <tr id="y98mgu_154">
         <td id="y98mgu_177">
          <p>
           <code class="code" id="y98mgu_181">
            Byte
           </code>
          </p>
         </td>
         <td id="y98mgu_178">
          <p>
           <code class="code" id="y98mgu_182">
            KotlinByte
           </code>
          </p>
         </td>
         <td id="y98mgu_179">
          <p>
           <code class="code" id="y98mgu_183">
            &lt;Package&gt;Byte
           </code>
          </p>
         </td>
         <td id="y98mgu_180">
          <p>
           <code class="code" id="y98mgu_184">
            char
           </code>
          </p>
         </td>
        </tr>
        <tr id="y98mgu_155">
         <td id="y98mgu_185">
          <p>
           <code class="code" id="y98mgu_189">
            UByte
           </code>
          </p>
         </td>
         <td id="y98mgu_186">
          <p>
           <code class="code" id="y98mgu_190">
            KotlinUByte
           </code>
          </p>
         </td>
         <td id="y98mgu_187">
          <p>
           <code class="code" id="y98mgu_191">
            &lt;Package&gt;UByte
           </code>
          </p>
         </td>
         <td id="y98mgu_188">
          <p>
           <code class="code" id="y98mgu_192">
            unsigned char
           </code>
          </p>
         </td>
        </tr>
        <tr id="y98mgu_156">
         <td id="y98mgu_193">
          <p>
           <code class="code" id="y98mgu_197">
            Short
           </code>
          </p>
         </td>
         <td id="y98mgu_194">
          <p>
           <code class="code" id="y98mgu_198">
            KotlinShort
           </code>
          </p>
         </td>
         <td id="y98mgu_195">
          <p>
           <code class="code" id="y98mgu_199">
            &lt;Package&gt;Short
           </code>
          </p>
         </td>
         <td id="y98mgu_196">
          <p>
           <code class="code" id="y98mgu_200">
            short
           </code>
          </p>
         </td>
        </tr>
        <tr id="y98mgu_157">
         <td id="y98mgu_201">
          <p>
           <code class="code" id="y98mgu_205">
            UShort
           </code>
          </p>
         </td>
         <td id="y98mgu_202">
          <p>
           <code class="code" id="y98mgu_206">
            KotlinUShort
           </code>
          </p>
         </td>
         <td id="y98mgu_203">
          <p>
           <code class="code" id="y98mgu_207">
            &lt;Package&gt;UShort
           </code>
          </p>
         </td>
         <td id="y98mgu_204">
          <p>
           <code class="code" id="y98mgu_208">
            unsigned short
           </code>
          </p>
         </td>
        </tr>
        <tr id="y98mgu_158">
         <td id="y98mgu_209">
          <p>
           <code class="code" id="y98mgu_213">
            Int
           </code>
          </p>
         </td>
         <td id="y98mgu_210">
          <p>
           <code class="code" id="y98mgu_214">
            KotlinInt
           </code>
          </p>
         </td>
         <td id="y98mgu_211">
          <p>
           <code class="code" id="y98mgu_215">
            &lt;Package&gt;Int
           </code>
          </p>
         </td>
         <td id="y98mgu_212">
          <p>
           <code class="code" id="y98mgu_216">
            int
           </code>
          </p>
         </td>
        </tr>
        <tr id="y98mgu_159">
         <td id="y98mgu_217">
          <p>
           <code class="code" id="y98mgu_221">
            UInt
           </code>
          </p>
         </td>
         <td id="y98mgu_218">
          <p>
           <code class="code" id="y98mgu_222">
            KotlinUInt
           </code>
          </p>
         </td>
         <td id="y98mgu_219">
          <p>
           <code class="code" id="y98mgu_223">
            &lt;Package&gt;UInt
           </code>
          </p>
         </td>
         <td id="y98mgu_220">
          <p>
           <code class="code" id="y98mgu_224">
            unsigned int
           </code>
          </p>
         </td>
        </tr>
        <tr id="y98mgu_160">
         <td id="y98mgu_225">
          <p>
           <code class="code" id="y98mgu_229">
            Long
           </code>
          </p>
         </td>
         <td id="y98mgu_226">
          <p>
           <code class="code" id="y98mgu_230">
            KotlinLong
           </code>
          </p>
         </td>
         <td id="y98mgu_227">
          <p>
           <code class="code" id="y98mgu_231">
            &lt;Package&gt;Long
           </code>
          </p>
         </td>
         <td id="y98mgu_228">
          <p>
           <code class="code" id="y98mgu_232">
            long long
           </code>
          </p>
         </td>
        </tr>
        <tr id="y98mgu_161">
         <td id="y98mgu_233">
          <p>
           <code class="code" id="y98mgu_237">
            ULong
           </code>
          </p>
         </td>
         <td id="y98mgu_234">
          <p>
           <code class="code" id="y98mgu_238">
            KotlinULong
           </code>
          </p>
         </td>
         <td id="y98mgu_235">
          <p>
           <code class="code" id="y98mgu_239">
            &lt;Package&gt;ULong
           </code>
          </p>
         </td>
         <td id="y98mgu_236">
          <p>
           <code class="code" id="y98mgu_240">
            unsigned long long
           </code>
          </p>
         </td>
        </tr>
        <tr id="y98mgu_162">
         <td id="y98mgu_241">
          <p>
           <code class="code" id="y98mgu_245">
            Float
           </code>
          </p>
         </td>
         <td id="y98mgu_242">
          <p>
           <code class="code" id="y98mgu_246">
            KotlinFloat
           </code>
          </p>
         </td>
         <td id="y98mgu_243">
          <p>
           <code class="code" id="y98mgu_247">
            &lt;Package&gt;Float
           </code>
          </p>
         </td>
         <td id="y98mgu_244">
          <p>
           <code class="code" id="y98mgu_248">
            float
           </code>
          </p>
         </td>
        </tr>
        <tr id="y98mgu_163">
         <td id="y98mgu_249">
          <p>
           <code class="code" id="y98mgu_253">
            Double
           </code>
          </p>
         </td>
         <td id="y98mgu_250">
          <p>
           <code class="code" id="y98mgu_254">
            KotlinDouble
           </code>
          </p>
         </td>
         <td id="y98mgu_251">
          <p>
           <code class="code" id="y98mgu_255">
            &lt;Package&gt;Double
           </code>
          </p>
         </td>
         <td id="y98mgu_252">
          <p>
           <code class="code" id="y98mgu_256">
            double
           </code>
          </p>
         </td>
        </tr>
        <tr id="y98mgu_164">
         <td id="y98mgu_257">
          <p>
           <code class="code" id="y98mgu_261">
            Boolean
           </code>
          </p>
         </td>
         <td id="y98mgu_258">
          <p>
           <code class="code" id="y98mgu_262">
            KotlinBoolean
           </code>
          </p>
         </td>
         <td id="y98mgu_259">
          <p>
           <code class="code" id="y98mgu_263">
            &lt;Package&gt;Boolean
           </code>
          </p>
         </td>
         <td id="y98mgu_260">
          <p>
           <code class="code" id="y98mgu_264">
            BOOL/Bool
           </code>
          </p>
         </td>
        </tr>
       </tbody>
      </table>
     </div>
     <p id="y98mgu_143">
      Every number type has a class method to create a new instance from the corresponding simple type. Also, there is an instance method to extract a simple value back. Schematically, all such declarations look like that:
     </p>
     <div class="code-block" data-lang="objectivec">
      __attribute__((swift_name("Kotlin__TYPE__")))
@interface Demo__TYPE__ : DemoNumber
- (instancetype)initWith__TYPE__:(__CTYPE__)value;
+ (instancetype)numberWith__TYPE__:(__CTYPE__)value;
@end;
     </div>
     <p id="y98mgu_145">
      Here,
      <code class="code" id="y98mgu_265">
       __TYPE__
      </code>
      is one of the simple type names, and
      <code class="code" id="y98mgu_266">
       __CTYPE__
      </code>
      is the corresponding Objective-C type, for example,
      <code class="code" id="y98mgu_267">
       initWithChar(char)
      </code>
      .
     </p>
     <p id="y98mgu_146">
      These types are used to map boxed Kotlin number types to Swift/Objective-C. In Swift, you can call the constructor to create an instance, for example,
      <code class="code" id="y98mgu_268">
       KotlinLong(value: 42)
      </code>
      .
     </p>
    </section>
    <section class="chapter">
     <h3 data-toc="classes-and-objects-from-kotlin" id="classes-and-objects-from-kotlin">
      Classes and objects from Kotlin
     </h3>
     <p id="y98mgu_269">
      Let's see how
      <code class="code" id="y98mgu_273">
       class
      </code>
      and
      <code class="code" id="y98mgu_274">
       object
      </code>
      are mapped to Swift/Objective-C. The generated
      <code class="code" id="y98mgu_275">
       Demo.h
      </code>
      file contains the exact definitions for
      <code class="code" id="y98mgu_276">
       Class
      </code>
      ,
      <code class="code" id="y98mgu_277">
       Interface
      </code>
      , and
      <code class="code" id="y98mgu_278">
       Object
      </code>
      :
     </p>
     <div class="code-block" data-lang="objectivec">
      __attribute__((swift_name("Interface")))
@protocol DemoInterface
@required
- (void)iMember __attribute__((swift_name("iMember()")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Clazz")))
@interface DemoClazz : DemoBase &lt;DemoInterface&gt;
- (instancetype)init __attribute__((swift_name("init()"))) __attribute__((objc_designated_initializer));
+ (instancetype)new __attribute__((availability(swift, unavailable, message="use object initializers instead")));
- (DemoULong * _Nullable)memberP:(int32_t)p __attribute__((swift_name("member(p:)")));
@end

__attribute__((objc_subclassing_restricted))
__attribute__((swift_name("Object")))
@interface DemoObject : DemoBase
+ (instancetype)alloc __attribute__((unavailable));
+ (instancetype)allocWithZone:(struct _NSZone *)zone __attribute__((unavailable));
+ (instancetype)object __attribute__((swift_name("init()")));
@property (class, readonly, getter=shared) DemoObject *shared __attribute__((swift_name("shared")));
@property (readonly) NSString *field __attribute__((swift_name("field")));
@end
     </div>
     <p id="y98mgu_271">
      Objective-C attributes in this code help use the framework from both Swift and Objective-C languages.
      <code class="code" id="y98mgu_279">
       DemoInterface
      </code>
      ,
      <code class="code" id="y98mgu_280">
       DemoClazz
      </code>
      , and
      <code class="code" id="y98mgu_281">
       DemoObject
      </code>
      are created for
      <code class="code" id="y98mgu_282">
       Interface
      </code>
      ,
      <code class="code" id="y98mgu_283">
       Clazz
      </code>
      , and
      <code class="code" id="y98mgu_284">
       Object
      </code>
      , respectively.
     </p>
     <p id="y98mgu_272">
      The
      <code class="code" id="y98mgu_285">
       Interface
      </code>
      is turned into
      <code class="code" id="y98mgu_286">
       @protocol
      </code>
      , while both a
      <code class="code" id="y98mgu_287">
       class
      </code>
      and an
      <code class="code" id="y98mgu_288">
       object
      </code>
      are represented as
      <code class="code" id="y98mgu_289">
       @interface
      </code>
      . The
      <code class="code" id="y98mgu_290">
       Demo
      </code>
      prefix comes from the framework name. The nullable return type
      <code class="code" id="y98mgu_291">
       ULong?
      </code>
      is turned into
      <code class="code" id="y98mgu_292">
       DemoULong
      </code>
      in Objective-C.
     </p>
    </section>
    <section class="chapter">
     <h3 data-toc="global-declarations-from-kotlin" id="global-declarations-from-kotlin">
      Global declarations from Kotlin
     </h3>
     <p id="y98mgu_293">
      All global functions from Kotlin are turned into
      <code class="code" id="y98mgu_297">
       DemoLibKt
      </code>
      in Objective-C and into
      <code class="code" id="y98mgu_298">
       LibKt
      </code>
      in Swift, where
      <code class="code" id="y98mgu_299">
       Demo
      </code>
      is the framework name set by the
      <code class="code" id="y98mgu_300">
       -output
      </code>
      parameter of
      <code class="code" id="y98mgu_301">
       kotlinc-native
      </code>
      :
     </p>
     <div class="code-block" data-lang="objectivec">
      __attribute__((objc_subclassing_restricted))
__attribute__((swift_name("LibKt")))
@interface DemoLibKt : DemoBase
+ (NSString * _Nullable)acceptFunF:(NSString * _Nullable (^)(NSString *))f __attribute__((swift_name("acceptFun(f:)")));
+ (void)forFloatsF:(float)f d:(DemoDouble * _Nullable)d __attribute__((swift_name("forFloats(f:d:)")));
+ (void)forIntegersB:(int8_t)b s:(uint16_t)s i:(int32_t)i l:(DemoULong * _Nullable)l __attribute__((swift_name("forIntegers(b:s:i:l:)")));
+ (NSString *)stringsStr:(NSString * _Nullable)str __attribute__((swift_name("strings(str:)")));
+ (NSString * _Nullable (^)(NSString *))supplyFun __attribute__((swift_name("supplyFun()")));
@end
     </div>
     <p id="y98mgu_295">
      Kotlin
      <code class="code" id="y98mgu_302">
       String
      </code>
      and Objective-C
      <code class="code" id="y98mgu_303">
       NSString*
      </code>
      are mapped transparently. Similarly,
      <code class="code" id="y98mgu_304">
       Unit
      </code>
      type from Kotlin is mapped to
      <code class="code" id="y98mgu_305">
       void
      </code>
      . The primitive types are mapped directly. Non-nullable primitive types are mapped transparently. Nullable primitive types are mapped to
      <code class="code" id="y98mgu_306">
       Kotlin&lt;TYPE&gt;*
      </code>
      types, as shown in the
      <a data-tooltip="The next part of the Demo.h file contains type mappings between Kotlin/Native number types and NSNumber. The base class is called DemoNumber in Objective-C and KotlinNumber in Swift. It extends NSNumber." href="#kotlin-numbers-and-nsnumber" id="y98mgu_307">
       table
      </a>
      . Both higher-order functions
      <code class="code" id="y98mgu_308">
       acceptFunF
      </code>
      and
      <code class="code" id="y98mgu_309">
       supplyFun
      </code>
      are included and accept Objective-C blocks.
     </p>
     <p id="y98mgu_296">
      You can find more information about type mapping in
      <a data-tooltip="The table below shows how Kotlin concepts are mapped to Swift/Objective-C and vice versa." href="native-objc-interop.html#mappings" id="y98mgu_310">
       Interoperability with Swift/Objective-C
      </a>
      .
     </p>
    </section>
   </section>
   <section class="chapter">
    <h2 data-toc="garbage-collection-and-reference-counting" id="garbage-collection-and-reference-counting">
     Garbage collection and reference counting
    </h2>
    <p id="y98mgu_311">
     Swift and Objective-C use automatic reference counting (ARC). Kotlin/Native has its own
     <a data-tooltip="Kotlin/Native's garbage collector (GC) algorithm is constantly evolving. Currently, it functions as a stop-the-world mark and concurrent sweep collector that does not separate the heap into generations." href="native-memory-manager.html#garbage-collector" id="y98mgu_313">
      garbage collector
     </a>
     , which is also
     <a data-tooltip="Kotlin and Objective-C use different memory management strategies. Kotlin has a tracing garbage collector, while Objective-C relies on automatic reference counting (ARC)." href="native-arc-integration.html" id="y98mgu_314">
      integrated with Objective-C/Swift ARC
     </a>
     .
    </p>
    <p id="y98mgu_312">
     Unused Kotlin objects are automatically removed. You don't need to take additional steps to control the lifetime of Kotlin/Native instances from Swift or Objective-C.
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="use-code-from-objective-c" id="use-code-from-objective-c">
     Use code from Objective-C
    </h2>
    <p id="y98mgu_315">
     Let's call the framework from Objective-C. In the framework directory, create the
     <code class="code" id="y98mgu_321">
      main.m
     </code>
     file with the following code:
    </p>
    <div class="code-block" data-lang="objectivec">
     #import &lt;Foundation/Foundation.h&gt;
#import &lt;Demo/Demo.h&gt;

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        [DemoObject.shared field];
        
        DemoClazz* clazz = [[ DemoClazz alloc] init];
        [clazz memberP:42];
        
        [DemoLibKt forIntegersB:1 s:1 i:3 l:[DemoULong numberWithUnsignedLongLong:4]];
        [DemoLibKt forIntegersB:1 s:1 i:3 l:nil];
        
        [DemoLibKt forFloatsF:2.71 d:[DemoDouble numberWithDouble:2.71]];
        [DemoLibKt forFloatsF:2.71 d:nil];
        
        NSString* ret = [DemoLibKt acceptFunF:^NSString * _Nullable(NSString * it) {
            return [it stringByAppendingString:@" Kotlin is fun"];
        }];
        
        NSLog(@"%@", ret);
        return 0;
    }
}
    </div>
    <p id="y98mgu_317">
     Here, you call Kotlin classes directly from Objective-C code. A Kotlin object uses the
     <code class="code" id="y98mgu_322">
      &lt;object name&gt;.shared
     </code>
     class property, which allows you to get the object's only instance and call object methods on it.
    </p>
    <p id="y98mgu_318">
     The widespread pattern is used to create an instance of the
     <code class="code" id="y98mgu_323">
      Clazz
     </code>
     class. You call the
     <code class="code" id="y98mgu_324">
      [[ DemoClazz alloc] init]
     </code>
     on Objective-C. You can also use
     <code class="code" id="y98mgu_325">
      [DemoClazz new]
     </code>
     for constructors without parameters.
    </p>
    <p id="y98mgu_319">
     Global declarations from the Kotlin sources are scoped under the
     <code class="code" id="y98mgu_326">
      DemoLibKt
     </code>
     class in Objective-C. All Kotlin functions are turned into class methods of that class.
    </p>
    <p id="y98mgu_320">
     The
     <code class="code" id="y98mgu_327">
      strings
     </code>
     function is turned into
     <code class="code" id="y98mgu_328">
      DemoLibKt.stringsStr
     </code>
     function in Objective-C, so you can pass
     <code class="code" id="y98mgu_329">
      NSString
     </code>
     directly to it. The return value is visible as
     <code class="code" id="y98mgu_330">
      NSString
     </code>
     too.
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="use-code-from-swift" id="use-code-from-swift">
     Use code from Swift
    </h2>
    <p id="y98mgu_331">
     The framework you generated has helper attributes to make it easier to use with Swift. Let's convert the
     <a data-tooltip="Let's call the framework from Objective-C. In the framework directory, create the main.m file with the following code:" href="#use-code-from-objective-c" id="y98mgu_337">
      previous Objective-C example
     </a>
     into Swift.
    </p>
    <p id="y98mgu_332">
     In the framework directory, create the
     <code class="code" id="y98mgu_338">
      main.swift
     </code>
     file with the following code:
    </p>
    <div class="code-block" data-lang="swift">
     import Foundation
import Demo

let kotlinObject = Object.shared

let field = Object.shared.field

let clazz = Clazz()
clazz.member(p: 42)

LibKt.forIntegers(b: 1, s: 2, i: 3, l: 4)
LibKt.forFloats(f: 2.71, d: nil)

let ret = LibKt.acceptFun { "\($0) Kotlin is fun" }
if (ret != nil) {
    print(ret!)
}
    </div>
    <p id="y98mgu_334">
     There are some small differences between the original Kotlin code and its Swift version. In Kotlin, any object declaration has only one instance. The
     <code class="code" id="y98mgu_339">
      Object.shared
     </code>
     syntax is used to access this single instance.
    </p>
    <p id="y98mgu_335">
     Kotlin function and property names are translated as is. Kotlin's
     <code class="code" id="y98mgu_340">
      String
     </code>
     is turned into Swift's
     <code class="code" id="y98mgu_341">
      String
     </code>
     . Swift hides
     <code class="code" id="y98mgu_342">
      NSNumber*
     </code>
     boxing too. You can also pass a Swift closure to Kotlin and call a Kotlin lambda function from Swift.
    </p>
    <p id="y98mgu_336">
     You can find more information about type mapping in
     <a data-tooltip="The table below shows how Kotlin concepts are mapped to Swift/Objective-C and vice versa." href="native-objc-interop.html#mappings" id="y98mgu_343">
      Interoperability with Swift/Objective-C
     </a>
     .
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="connect-the-framework-to-your-ios-project" id="connect-the-framework-to-your-ios-project">
     Connect the framework to your iOS project
    </h2>
    <p id="y98mgu_344">
     Now you can connect the generated framework to your iOS project as a dependency. There are multiple ways to set it up and automate the process, choose the method that suits you best:
    </p>
    <p id="y98mgu_345">
     <a data-tooltip="You can integrate a Kotlin Multiplatform shared module into your iOS app. For that, you generate an iOS framework from the shared module and then add it as a dependency to the iOS project:" href="multiplatform-ios-integration-overview.html" id="y98mgu_346">
      <figure id="y98mgu_347">
       <img alt="Choose iOS integration method" height="52" src="images/choose-ios-integration.svg" title="Choose iOS integration method" width="700"/>
      </figure>
     </a>
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="what-s-next" id="what-s-next">
     What's next
    </h2>
    <ul class="list _bullet" id="y98mgu_348">
     <li class="list__item" id="y98mgu_349">
      <p>
       <a data-tooltip="The Objective-C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from Objective-C libraries should have the @ExperimentalForeignApi annotation." href="native-objc-interop.html" id="y98mgu_352">
        Learn more about interoperability with Objective-C
       </a>
      </p>
     </li>
     <li class="list__item" id="y98mgu_350">
      <p>
       <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="native-c-interop.html" id="y98mgu_353">
        See how interoperability with C is implemented in Kotlin
       </a>
      </p>
     </li>
     <li class="list__item" id="y98mgu_351">
      <p>
       <a data-tooltip="You can create dynamic libraries to use Kotlin code from existing programs. This enables code sharing across many platforms or languages, including JVM, Python, Android, and others." href="native-dynamic-libraries.html" id="y98mgu_354">
        Check out the Kotlin/Native as a dynamic library tutorial
       </a>
      </p>
     </li>
    </ul>
   </section>
   <div class="last-modified">
    Last modified: 16 December 2024
   </div>
   <div data-feedback-placeholder="true">
   </div>
  </div>
 </body>
</html>
