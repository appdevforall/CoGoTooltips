<html>
 <head>
  <meta charset="utf-8"/>
  <link href="doc_style.css" rel="stylesheet"/>
 </head>
 <body>
  <a class="menu-link" href="toc.html">
   MENU
  </a>
  <hr/>
  <div class="article-content">
   <h1 data-toc="mapping-struct-union-types-from-c" id="mapping-struct-union-types-from-c.md">
    Mapping struct and union types from C – tutorial
   </h1>
   <aside class="prompt" data-title="" data-type="warning" id="z1ujcqm_2">
    <p id="z1ujcqm_12">
     The C libraries import is
     <a data-tooltip="Here's a quick guide to these stability levels and their meaning:" href="components-stability.html#stability-levels-explained" id="z1ujcqm_14">
      Experimental
     </a>
     . All Kotlin declarations generated by the
     <code class="code" id="z1ujcqm_15">
      cinterop
     </code>
     tool from C libraries should have the
     <code class="code" id="z1ujcqm_16">
      @ExperimentalForeignApi
     </code>
     annotation.
    </p>
    <p id="z1ujcqm_13">
     Native platform libraries shipped with Kotlin/Native (like Foundation, UIKit, and POSIX), require opt-in only for some APIs. In such cases, you get an IDE warning.
    </p>
   </aside>
   <p id="z1ujcqm_3">
    This is the second post in the series. The very first tutorial of the series is
    <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="mapping-primitive-data-types-from-c.html" id="z1ujcqm_17">
     Mapping primitive data types from C
    </a>
    . There are also the
    <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="mapping-function-pointers-from-c.html" id="z1ujcqm_18">
     Mapping function pointers from C
    </a>
    and
    <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="mapping-strings-from-c.html" id="z1ujcqm_19">
     Mapping Strings from C
    </a>
    tutorials.
   </p>
   <p id="z1ujcqm_4">
    In the tutorial, you will learn:
   </p>
   <ul class="list _bullet" id="z1ujcqm_5">
    <li class="list__item" id="z1ujcqm_20">
     <p>
      <a data-tooltip="The best way to understand the mapping between Kotlin and C is to try a tiny example. We will declare a struct and a union in the C language, to see how they are mapped into Kotlin." href="#mapping-struct-and-union-c-types" id="z1ujcqm_22">
       How struct and union types are mapped
      </a>
     </p>
    </li>
    <li class="list__item" id="z1ujcqm_21">
     <p>
      <a data-tooltip="It is easy to use the generated wrapper classes for C struct and union types from Kotlin. Thanks to the generated properties, it feels natural to use them in Kotlin code. The only question, so far, is how to create a new instance on those classes. As you see from the declarations of…" href="#use-struct-and-union-types-from-kotlin" id="z1ujcqm_23">
       How to use struct and union type from Kotlin
      </a>
     </p>
    </li>
   </ul>
   <section class="chapter">
    <h2 data-toc="mapping-struct-and-union-c-types" id="mapping-struct-and-union-c-types">
     Mapping struct and union C types
    </h2>
    <p id="z1ujcqm_24">
     The best way to understand the mapping between Kotlin and C is to try a tiny example. We will declare a struct and a union in the C language, to see how they are mapped into Kotlin.
    </p>
    <p id="z1ujcqm_25">
     Kotlin/Native comes with the
     <code class="code" id="z1ujcqm_29">
      cinterop
     </code>
     tool, the tool generates bindings between the C language and Kotlin. It uses a
     <code class="code" id="z1ujcqm_30">
      .def
     </code>
     file to specify a C library to import. More details are discussed in the
     <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="native-c-interop.html" id="z1ujcqm_31">
      Interop with C Libraries
     </a>
     tutorial.
    </p>
    <p id="z1ujcqm_26">
     In
     <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="mapping-primitive-data-types-from-c.html" id="z1ujcqm_32">
      the previous tutorial
     </a>
     , you've created a
     <code class="code" id="z1ujcqm_33">
      lib.h
     </code>
     file. This time, include those declarations directly into the
     <code class="code" id="z1ujcqm_34">
      interop.def
     </code>
     file, after the
     <code class="code" id="z1ujcqm_35">
      ---
     </code>
     separator line:
    </p>
    <div class="code-block" data-lang="c">
     ---

typedef struct {
  int a;
  double b;
} MyStruct;

void struct_by_value(MyStruct s) {}
void struct_by_pointer(MyStruct* s) {}

typedef union {
  int a;
  MyStruct b;
  float c;
} MyUnion;

void union_by_value(MyUnion u) {}
void union_by_pointer(MyUnion* u) {}
    </div>
    <p id="z1ujcqm_28">
     The
     <code class="code" id="z1ujcqm_36">
      interop.def
     </code>
     file is enough to compile and run the application or open it in an IDE. Now it is time to create project files, open the project in
     <a data-external="true" href="https://jetbrains.com/idea" id="z1ujcqm_37" rel="noopener noreferrer">
      IntelliJ IDEA
     </a>
     and run it.
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="inspect-generated-kotlin-apis-for-a-c-library" id="inspect-generated-kotlin-apis-for-a-c-library">
     Inspect Generated Kotlin APIs for a C library
    </h2>
    <p id="z1ujcqm_38">
     While it is possible to use the command line, either directly or by combining it with a script file (such as
     <code class="code" id="z1ujcqm_47">
      .sh
     </code>
     or
     <code class="code" id="z1ujcqm_48">
      .bat
     </code>
     file), this approach doesn't scale well for big projects that have hundreds of files and libraries. It is then better to use the Kotlin/Native compiler with a build system, as it helps to download and cache the Kotlin/Native compiler binaries and libraries with transitive dependencies and run the compiler and tests. Kotlin/Native can use the
     <a data-external="true" href="https://gradle.org" id="z1ujcqm_49" rel="noopener noreferrer">
      Gradle
     </a>
     build system through the
     <a data-tooltip="Projects targeting multiple platforms, called multiplatform projects, require the kotlin-multiplatform plugin." href="gradle-configure-project.html#targeting-multiple-platforms" id="z1ujcqm_50">
      kotlin-multiplatform
     </a>
     plugin.
    </p>
    <p id="z1ujcqm_39">
     We covered the basics of setting up an IDE compatible project with Gradle in the
     <a data-tooltip="In this section, you'll learn how to manually create a Kotlin/Native application using Gradle. It's the default build system for Kotlin/Native and Kotlin Multiplatform projects, which is also commonly used in Java, Android, and other ecosystems." href="native-get-started.html#using-gradle" id="z1ujcqm_51">
      Get started with Kotlin/Native
     </a>
     tutorial. Please check it out if you are looking for detailed first steps and instructions on how to start a new Kotlin/Native project and open it in IntelliJ IDEA. In this tutorial, we'll look at the advanced C interop related usages of Kotlin/Native and
     <a data-tooltip="Projects targeting multiple platforms, called multiplatform projects, require the kotlin-multiplatform plugin." href="gradle-configure-project.html#targeting-multiple-platforms" id="z1ujcqm_52">
      multiplatform
     </a>
     builds with Gradle.
    </p>
    <p id="z1ujcqm_40">
     First, create a project folder. All the paths in this tutorial will be relative to this folder. Sometimes the missing directories will have to be created before any new files can be added.
    </p>
    <p id="z1ujcqm_41">
     Use the following
     <code class="code" id="z1ujcqm_53">
      build.gradle(.kts)
     </code>
     Gradle build file:
    </p>
    <div class="tabs" data-anchors="[z1ujcqm_54,z1ujcqm_55]" data-group="build-script" id="z1ujcqm_42">
     <div class="tabs__content" data-gtm="tab" data-sync-tabs="kotlin" data-title="Kotlin" id="z1ujcqm_54">
      <div class="code-block" data-lang="kotlin" data-title="Kotlin">
       plugins {
    kotlin("multiplatform") version "2.1.0"
}

repositories {
    mavenCentral()
}

kotlin {
  linuxX64("native") { // on Linux
  // macosX64("native") { // on x86_64 macOS
  // macosArm64("native") { // on Apple Silicon macOS
  // mingwX64("native") { // on Windows
    val main by compilations.getting
    val interop by main.cinterops.creating
    
    binaries {
      executable()
    }
  }
}

tasks.wrapper {
  gradleVersion = "8.10"
  distributionType = Wrapper.DistributionType.BIN
}
      </div>
     </div>
     <div class="tabs__content" data-gtm="tab" data-sync-tabs="groovy" data-title="Groovy" id="z1ujcqm_55">
      <div class="code-block" data-lang="groovy" data-title="Groovy">
       plugins {
    id 'org.jetbrains.kotlin.multiplatform' version '2.1.0'
}

repositories {
    mavenCentral()
}

kotlin {
  linuxX64('native') { // on Linux
  // macosX64("native") { // on x86_64 macOS
  // macosArm64("native") { // on Apple Silicon macOS
  // mingwX64('native') { // on Windows
    compilations.main.cinterops {
      interop 
    }
    
    binaries {
      executable()
    }
  }
}

wrapper {
  gradleVersion = '8.10'
  distributionType = 'BIN'
}
      </div>
     </div>
    </div>
    <p id="z1ujcqm_43">
     The project file configures the C interop as an additional step of the build. Let's move the
     <code class="code" id="z1ujcqm_58">
      interop.def
     </code>
     file to the
     <code class="code" id="z1ujcqm_59">
      src/nativeInterop/cinterop
     </code>
     directory. Gradle recommends using conventions instead of configurations, for example, the source files are expected to be in the
     <code class="code" id="z1ujcqm_60">
      src/nativeMain/kotlin
     </code>
     folder. By default, all the symbols from C are imported to the
     <code class="code" id="z1ujcqm_61">
      interop
     </code>
     package, you may want to import the whole package in our
     <code class="code" id="z1ujcqm_62">
      .kt
     </code>
     files. Check out the
     <a data-tooltip="The Kotlin Multiplatform Gradle plugin is a tool for creating Kotlin Multiplatform projects. Here we provide a reference of its contents; use it as a reminder when writing Gradle build scripts for Kotlin Multiplatform projects. Learn the concepts of Kotlin Multiplatform projects,…" href="multiplatform-dsl-reference.html" id="z1ujcqm_63">
      Multiplatform Gradle DSL reference
     </a>
     to learn about all the different ways you could configure it.
    </p>
    <p id="z1ujcqm_44">
     Create a
     <code class="code" id="z1ujcqm_64">
      src/nativeMain/kotlin/hello.kt
     </code>
     stub file with the following content to see how C struct and union declarations are visible from Kotlin:
    </p>
    <div class="code-block" data-lang="kotlin">
     import interop.*

fun main() {
  println("Hello Kotlin/Native!")
  
  struct_by_value(/* fix me*/)
  struct_by_pointer(/* fix me*/)
  union_by_value(/* fix me*/)
  union_by_pointer(/* fix me*/)
}
    </div>
    <p id="z1ujcqm_46">
     Now you are ready to
     <a data-tooltip="In this tutorial, you'll learn how to create a Kotlin/Native application. Choose the tool that works best for you and create your app using:" href="native-get-started.html" id="z1ujcqm_65">
      open the project in IntelliJ IDEA
     </a>
     and to see how to fix the example project. While doing that, see how C struct and union types are mapped into Kotlin/Native.
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="struct-and-union-types-in-kotlin" id="struct-and-union-types-in-kotlin">
     Struct and union types in Kotlin
    </h2>
    <p id="z1ujcqm_66">
     With the help of IntelliJ IDEA's
     <span class="control" id="z1ujcqm_71">
      Go to | Declaration
     </span>
     or compiler errors, you see the following generated API for the C functions,
     <code class="code" id="z1ujcqm_72">
      struct
     </code>
     , and
     <code class="code" id="z1ujcqm_73">
      union
     </code>
     :
    </p>
    <div class="code-block" data-lang="kotlin">
     fun struct_by_value(s: CValue&lt;MyStruct&gt;)
fun struct_by_pointer(s: CValuesRef&lt;MyStruct&gt;?)

fun union_by_value(u: CValue&lt;MyUnion&gt;)
fun union_by_pointer(u: CValuesRef&lt;MyUnion&gt;?)

class MyStruct constructor(rawPtr: NativePtr /* = NativePtr */) : CStructVar {
    var a: Int
    var b: Double
    companion object : CStructVar.Type
}

class MyUnion constructor(rawPtr: NativePtr /* = NativePtr */) : CStructVar {
    var a: Int
    val b: MyStruct
    var c: Float
    companion object : CStructVar.Type
}
    </div>
    <p id="z1ujcqm_68">
     You see that
     <code class="code" id="z1ujcqm_74">
      cinterop
     </code>
     generated wrapper types for our
     <code class="code" id="z1ujcqm_75">
      struct
     </code>
     and
     <code class="code" id="z1ujcqm_76">
      union
     </code>
     types. For
     <code class="code" id="z1ujcqm_77">
      MyStruct
     </code>
     and
     <code class="code" id="z1ujcqm_78">
      MyUnion
     </code>
     type declarations in C, there are the Kotlin classes
     <code class="code" id="z1ujcqm_79">
      MyStruct
     </code>
     and
     <code class="code" id="z1ujcqm_80">
      MyUnion
     </code>
     generated respectively. The wrappers inherit from the
     <code class="code" id="z1ujcqm_81">
      CStructVar
     </code>
     base class and declare all fields as Kotlin properties. It uses
     <code class="code" id="z1ujcqm_82">
      CValue&lt;T&gt;
     </code>
     to represent a by-value structure parameter and
     <code class="code" id="z1ujcqm_83">
      CValuesRef&lt;T&gt;?
     </code>
     to represent passing a pointer to a structure or a union.
    </p>
    <p id="z1ujcqm_69">
     Technically, there is no difference between
     <code class="code" id="z1ujcqm_84">
      struct
     </code>
     and
     <code class="code" id="z1ujcqm_85">
      union
     </code>
     types on the Kotlin side. Note that
     <code class="code" id="z1ujcqm_86">
      a
     </code>
     ,
     <code class="code" id="z1ujcqm_87">
      b
     </code>
     , and
     <code class="code" id="z1ujcqm_88">
      c
     </code>
     properties of
     <code class="code" id="z1ujcqm_89">
      MyUnion
     </code>
     class in Kotlin use the same memory location to read/write their value just like
     <code class="code" id="z1ujcqm_90">
      union
     </code>
     does in C language.
    </p>
    <p id="z1ujcqm_70">
     More details and advanced use-cases are presented in the
     <br/>
     <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="native-c-interop.html" id="z1ujcqm_92">
      C Interop documentation
     </a>
    </p>
   </section>
   <section class="chapter">
    <h2 data-toc="use-struct-and-union-types-from-kotlin" id="use-struct-and-union-types-from-kotlin">
     Use struct and union types from Kotlin
    </h2>
    <p id="z1ujcqm_93">
     It is easy to use the generated wrapper classes for C
     <code class="code" id="z1ujcqm_98">
      struct
     </code>
     and
     <code class="code" id="z1ujcqm_99">
      union
     </code>
     types from Kotlin. Thanks to the generated properties, it feels natural to use them in Kotlin code. The only question, so far, is how to create a new instance on those classes. As you see from the declarations of
     <code class="code" id="z1ujcqm_100">
      MyStruct
     </code>
     and
     <code class="code" id="z1ujcqm_101">
      MyUnion
     </code>
     , their constructors require a
     <code class="code" id="z1ujcqm_102">
      NativePtr
     </code>
     . Of course, you are not willing to deal with pointers manually. Instead, you can use Kotlin API to have those objects instantiated for us.
    </p>
    <p id="z1ujcqm_94">
     Let's take a look at the generated functions that take our
     <code class="code" id="z1ujcqm_103">
      MyStruct
     </code>
     and
     <code class="code" id="z1ujcqm_104">
      MyUnion
     </code>
     as parameters. You see that by-value parameters are represented as
     <code class="code" id="z1ujcqm_105">
      kotlinx.cinterop.CValue&lt;T&gt;
     </code>
     . And for typed pointer parameters you see
     <code class="code" id="z1ujcqm_106">
      kotlinx.cinterop.CValuesRef&lt;T&gt;
     </code>
     . Kotlin provides us with an API to deal with both types easily, let's try it and see.
    </p>
    <section class="chapter">
     <h3 data-toc="create-a-cvalue-t" id="create-a-cvalue-t">
      Create a CValue&lt;T&gt;
     </h3>
     <p id="z1ujcqm_108">
      <code class="code" id="z1ujcqm_112">
       CValue&lt;T&gt;
      </code>
      type is used to pass by-value parameters to a C function call. Use
      <code class="code" id="z1ujcqm_113">
       cValue
      </code>
      function to create
      <code class="code" id="z1ujcqm_114">
       CValue&lt;T&gt;
      </code>
      object instance. The function requires a
      <a data-tooltip="Function types with receiver, such as A.(B) -&gt; C, can be instantiated with a special form of function literals – function literals with receiver." href="lambdas.html#function-literals-with-receiver" id="z1ujcqm_115">
       lambda function with a receiver
      </a>
      to initialize the underlying C type in-place. The function is declared as follows:
     </p>
     <div class="code-block" data-lang="kotlin">
      fun &lt;reified T : CStructVar&gt; cValue(initialize: T.() -&gt; Unit): CValue&lt;T&gt;
     </div>
     <p id="z1ujcqm_110">
      Now it is time to see how to use
      <code class="code" id="z1ujcqm_116">
       cValue
      </code>
      and pass by-value parameters:
     </p>
     <div class="code-block" data-lang="kotlin">
      fun callValue() {

  val cStruct = cValue&lt;MyStruct&gt; {
    a = 42
    b = 3.14
  }
  struct_by_value(cStruct)

  val cUnion = cValue&lt;MyUnion&gt; {
    b.a = 5
    b.b = 2.7182
  }

  union_by_value(cUnion)
}
     </div>
    </section>
    <section class="chapter">
     <h3 data-toc="create-struct-and-union-as-cvaluesref-t" id="create-struct-and-union-as-cvaluesref-t">
      Create struct and union as CValuesRef&lt;T&gt;
     </h3>
     <p id="z1ujcqm_118">
      <code class="code" id="z1ujcqm_129">
       CValuesRef&lt;T&gt;
      </code>
      type is used in Kotlin to pass a typed pointer parameter of a C function. First, you need an instance of
      <code class="code" id="z1ujcqm_130">
       MyStruct
      </code>
      and
      <code class="code" id="z1ujcqm_131">
       MyUnion
      </code>
      classes. Create them directly in the native memory. Use the
     </p>
     <div class="code-block" data-lang="kotlin">
      fun &lt;reified T : kotlinx.cinterop.CVariable&gt; alloc(): T
     </div>
     <p id="z1ujcqm_120">
      extension function on
      <code class="code" id="z1ujcqm_132">
       kotlinx.cinterop.NativePlacement
      </code>
      type for this.
     </p>
     <p id="z1ujcqm_121">
      <code class="code" id="z1ujcqm_133">
       NativePlacement
      </code>
      represents native memory with functions similar to
      <code class="code" id="z1ujcqm_134">
       malloc
      </code>
      and
      <code class="code" id="z1ujcqm_135">
       free
      </code>
      . There are several implementations of
      <code class="code" id="z1ujcqm_136">
       NativePlacement
      </code>
      . The global one is called with
      <code class="code" id="z1ujcqm_137">
       kotlinx.cinterop.nativeHeap
      </code>
      and don't forget to call the
      <code class="code" id="z1ujcqm_138">
       nativeHeap.free(..)
      </code>
      function to free the memory after use.
     </p>
     <p id="z1ujcqm_122">
      Another option is to use the
     </p>
     <div class="code-block" data-lang="kotlin">
      fun &lt;R&gt; memScoped(block: kotlinx.cinterop.MemScope.() -&gt; R): R
     </div>
     <p id="z1ujcqm_124">
      function. It creates a short-lived memory allocation scope, and all allocations will be cleaned up automatically at the end of the
      <code class="code" id="z1ujcqm_139">
       block
      </code>
      .
     </p>
     <p id="z1ujcqm_125">
      Your code to call functions with pointers will look like this:
     </p>
     <div class="code-block" data-lang="kotlin">
      fun callRef() {
  memScoped {
    val cStruct = alloc&lt;MyStruct&gt;()
    cStruct.a = 42
    cStruct.b = 3.14

    struct_by_pointer(cStruct.ptr)

val cUnion = alloc&lt;MyUnion&gt;()
    cUnion.b.a = 5
    cUnion.b.b = 2.7182

    union_by_pointer(cUnion.ptr)
  }
}
     </div>
     <p id="z1ujcqm_127">
      Note that this code uses the extension property
      <code class="code" id="z1ujcqm_140">
       ptr
      </code>
      which comes from a
      <code class="code" id="z1ujcqm_141">
       memScoped
      </code>
      lambda receiver type, to turn
      <code class="code" id="z1ujcqm_142">
       MyStruct
      </code>
      and
      <code class="code" id="z1ujcqm_143">
       MyUnion
      </code>
      instances into native pointers.
     </p>
     <p id="z1ujcqm_128">
      The
      <code class="code" id="z1ujcqm_144">
       MyStruct
      </code>
      and
      <code class="code" id="z1ujcqm_145">
       MyUnion
      </code>
      classes have the pointer to the native memory underneath. The memory will be released when a
      <code class="code" id="z1ujcqm_146">
       memScoped
      </code>
      function ends, which is equal to the end of its
      <code class="code" id="z1ujcqm_147">
       block
      </code>
      . Make sure that a pointer is not used outside of the
      <code class="code" id="z1ujcqm_148">
       memScoped
      </code>
      call. You may use
      <code class="code" id="z1ujcqm_149">
       Arena()
      </code>
      or
      <code class="code" id="z1ujcqm_150">
       nativeHeap
      </code>
      for pointers that should be available longer, or are cached inside a C library.
     </p>
    </section>
    <section class="chapter">
     <h3 data-toc="conversion-between-cvalue-t-and-cvaluesref-t" id="conversion-between-cvalue-t-and-cvaluesref-t">
      Conversion between CValue&lt;T&gt; and CValuesRef&lt;T&gt;
     </h3>
     <p id="z1ujcqm_152">
      Of course, there are use cases when you need to pass a struct as a value to one call, and then, to pass the same struct as a reference to another call. This is possible in Kotlin/Native too. A
      <code class="code" id="z1ujcqm_158">
       NativePlacement
      </code>
      will be needed here.
     </p>
     <p id="z1ujcqm_153">
      Let's see now
      <code class="code" id="z1ujcqm_159">
       CValue&lt;T&gt;
      </code>
      is turned to a pointer first:
     </p>
     <div class="code-block" data-lang="kotlin">
      fun callMix_ref() {
  val cStruct = cValue&lt;MyStruct&gt; {
    a = 42
    b = 3.14
  }
  
  memScoped { 
    struct_by_pointer(cStruct.ptr)
  }
}
     </div>
     <p id="z1ujcqm_155">
      This code uses the extension property
      <code class="code" id="z1ujcqm_160">
       ptr
      </code>
      which comes from
      <code class="code" id="z1ujcqm_161">
       memScoped
      </code>
      lambda receiver type to turn
      <code class="code" id="z1ujcqm_162">
       MyStruct
      </code>
      and
      <code class="code" id="z1ujcqm_163">
       MyUnion
      </code>
      instances into native pointers. Those pointers are only valid inside the
      <code class="code" id="z1ujcqm_164">
       memScoped
      </code>
      block.
     </p>
     <p id="z1ujcqm_156">
      For the opposite conversion, to turn a pointer into a by-value variable, we call the
      <code class="code" id="z1ujcqm_165">
       readValue()
      </code>
      extension function:
     </p>
     <div class="code-block" data-lang="kotlin">
      fun callMix_value() {
  memScoped {
    val cStruct = alloc&lt;MyStruct&gt;()
    cStruct.a = 42
    cStruct.b = 3.14

    struct_by_value(cStruct.readValue())
  }
}
     </div>
    </section>
   </section>
   <section class="chapter">
    <h2 data-toc="run-the-code" id="run-the-code">
     Run the code
    </h2>
    <p id="z1ujcqm_166">
     Now when you have learned how to use C declarations in your code, you are ready to try it out on a real example. Let's fix the code and see how it runs by calling the
     <code class="code" id="z1ujcqm_170">
      runDebugExecutableNative
     </code>
     Gradle task
     <a data-tooltip="In this tutorial, you'll learn how to create a Kotlin/Native application. Choose the tool that works best for you and create your app using:" href="native-get-started.html" id="z1ujcqm_171">
      in the IDE
     </a>
     or by using the following console command:
    </p>
    <div class="code-block" data-lang="bash">
     ./gradlew runDebugExecutableNative
    </div>
    <p id="z1ujcqm_168">
     The final code in the
     <code class="code" id="z1ujcqm_172">
      hello.kt
     </code>
     file may look like this:
    </p>
    <div class="code-block" data-lang="kotlin">
     import interop.*
import kotlinx.cinterop.alloc
import kotlinx.cinterop.cValue
import kotlinx.cinterop.memScoped
import kotlinx.cinterop.ptr
import kotlinx.cinterop.readValue

fun main() {
  println("Hello Kotlin/Native!")

  val cUnion = cValue&lt;MyUnion&gt; {
    b.a = 5
    b.b = 2.7182
  }

  memScoped {
    union_by_value(cUnion)
    union_by_pointer(cUnion.ptr)
  }

  memScoped {
    val cStruct = alloc&lt;MyStruct&gt; {
      a = 42
      b = 3.14
    }

    struct_by_value(cStruct.readValue())
    struct_by_pointer(cStruct.ptr)
  }
}
    </div>
   </section>
   <section class="chapter">
    <h2 data-toc="next-steps" id="next-steps">
     Next steps
    </h2>
    <p id="z1ujcqm_173">
     Continue exploring the C language types and their representation in Kotlin/Native in the related tutorials:
    </p>
    <ul class="list _bullet" id="z1ujcqm_174">
     <li class="list__item" id="z1ujcqm_176">
      <p>
       <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="mapping-primitive-data-types-from-c.html" id="z1ujcqm_179">
        Mapping primitive data types from C
       </a>
      </p>
     </li>
     <li class="list__item" id="z1ujcqm_177">
      <p>
       <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="mapping-function-pointers-from-c.html" id="z1ujcqm_180">
        Mapping function pointers from C
       </a>
      </p>
     </li>
     <li class="list__item" id="z1ujcqm_178">
      <p>
       <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="mapping-strings-from-c.html" id="z1ujcqm_181">
        Mapping strings from C
       </a>
      </p>
     </li>
    </ul>
    <p id="z1ujcqm_175">
     The
     <a data-tooltip="The C libraries import is Experimental. All Kotlin declarations generated by the cinterop tool from C libraries should have the @ExperimentalForeignApi annotation." href="native-c-interop.html" id="z1ujcqm_182">
      C Interop documentation
     </a>
     covers more advanced scenarios of the interop.
    </p>
   </section>
   <div class="last-modified">
    Last modified: 16 December 2024
   </div>
   <div data-feedback-placeholder="true">
   </div>
  </div>
 </body>
</html>
